<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原生函数 | 前端知识笔记</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.4b1b2517.css" as="style"><link rel="preload" href="/assets/js/app.735e6fcb.js" as="script"><link rel="preload" href="/assets/js/2.5cb423a9.js" as="script"><link rel="preload" href="/assets/js/27.484f76eb.js" as="script"><link rel="prefetch" href="/assets/js/10.003b1904.js"><link rel="prefetch" href="/assets/js/11.e6c51907.js"><link rel="prefetch" href="/assets/js/12.97f760ec.js"><link rel="prefetch" href="/assets/js/13.16a079d8.js"><link rel="prefetch" href="/assets/js/14.ba729c8e.js"><link rel="prefetch" href="/assets/js/15.98bc4478.js"><link rel="prefetch" href="/assets/js/16.9c982a45.js"><link rel="prefetch" href="/assets/js/17.bbebe80a.js"><link rel="prefetch" href="/assets/js/18.417f5bdf.js"><link rel="prefetch" href="/assets/js/19.c8b21384.js"><link rel="prefetch" href="/assets/js/20.6f51abd7.js"><link rel="prefetch" href="/assets/js/21.bf283b45.js"><link rel="prefetch" href="/assets/js/22.7be7440a.js"><link rel="prefetch" href="/assets/js/23.4742eeb2.js"><link rel="prefetch" href="/assets/js/24.d1d0ae86.js"><link rel="prefetch" href="/assets/js/25.05ddb5ef.js"><link rel="prefetch" href="/assets/js/26.f6b481a9.js"><link rel="prefetch" href="/assets/js/28.f775b8d4.js"><link rel="prefetch" href="/assets/js/29.d6781efc.js"><link rel="prefetch" href="/assets/js/3.3907cef8.js"><link rel="prefetch" href="/assets/js/30.82e04d36.js"><link rel="prefetch" href="/assets/js/31.d1b57a76.js"><link rel="prefetch" href="/assets/js/32.1d6b4690.js"><link rel="prefetch" href="/assets/js/33.8f0ed1db.js"><link rel="prefetch" href="/assets/js/4.9a0a833f.js"><link rel="prefetch" href="/assets/js/5.ce8228c5.js"><link rel="prefetch" href="/assets/js/6.77f60620.js"><link rel="prefetch" href="/assets/js/7.f2ca32c7.js"><link rel="prefetch" href="/assets/js/8.7ba72efb.js"><link rel="prefetch" href="/assets/js/9.3c298ae0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4b1b2517.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端知识笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/javaScript/type.html" class="sidebar-link">类型</a></li><li><a href="/javaScript/val.html" class="sidebar-link">值</a></li><li><a href="/javaScript/variable.html" class="sidebar-link">变量</a></li><li><a href="/javaScript/nativeFunction.html" class="active sidebar-link">原生函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/javaScript/nativeFunction.html#_1-内部属性-class" class="sidebar-link">1. 内部属性[[class]]</a></li><li class="sidebar-sub-header"><a href="/javaScript/nativeFunction.html#_2-封装对象包装" class="sidebar-link">2. 封装对象包装</a></li><li class="sidebar-sub-header"><a href="/javaScript/nativeFunction.html#_3-拆封" class="sidebar-link">3. 拆封</a></li><li class="sidebar-sub-header"><a href="/javaScript/nativeFunction.html#_4-原生函数作为构造函数" class="sidebar-link">4. 原生函数作为构造函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/javaScript/nativeFunction.html#_4-1-array" class="sidebar-link">4.1 Array(..)</a></li></ul></li><li class="sidebar-sub-header"><a href="/javaScript/nativeFunction.html#_4-2-object-、function-和regexp" class="sidebar-link">4.2 Object(..)、Function(..)和RegExp(..)</a></li><li class="sidebar-sub-header"><a href="/javaScript/nativeFunction.html#_4-3-symbol" class="sidebar-link">4.3 Symbol(..)</a></li><li class="sidebar-sub-header"><a href="/javaScript/nativeFunction.html#_4-5-原生原型" class="sidebar-link">4.5 原生原型</a></li></ul></li><li><a href="/javaScript/grammar.html" class="sidebar-link">语法</a></li><li><a href="/javaScript/asyn.html" class="sidebar-link">异步</a></li><li><a href="/javaScript/environment.html" class="sidebar-link">执行环境</a></li><li><a href="/javaScript/operating-mechanism.html" class="sidebar-link">运行机制</a></li><li><a href="/javaScript/closure.html" class="sidebar-link">闭包</a></li><li><a href="/javaScript/RAM.html" class="sidebar-link">内存问题</a></li><li><a href="/javaScript/object.html" class="sidebar-link">面向对象的程序设计</a></li><li><a href="/javaScript/Cross-domain.html" class="sidebar-link">跨域 与 Coment</a></li><li><a href="/javaScript/Simulation.html" class="sidebar-link">原理模拟实现</a></li><li><a href="/javaScript/advancedSkills.html" class="sidebar-link">高级技巧</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>读书笔记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="原生函数"><a href="#原生函数" class="header-anchor">#</a> 原生函数</h1> <p>js内建的函数也叫原生函数（native function）, 如string,number.</p> <p>常用的原生函数：</p> <ul><li><p>String()</p></li> <li><p>Number()</p></li> <li><p>Boolean()</p></li> <li><p>Array()</p></li> <li><p>Object</p></li> <li><p>Function()</p></li> <li><p>RegExp()</p></li> <li><p>Date()</p></li> <li><p>Error()</p></li> <li><p>Symbol()</p></li></ul> <h2 id="_1-内部属性-class"><a href="#_1-内部属性-class" class="header-anchor">#</a> 1. 内部属性[[class]]</h2> <p>所有typeof返回值为“object”的对象（如数组），都包含一个为内部属性[[class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义的类）。</p> <p>这个属性无法直接访问，一般通过Object.prototype.toStrin(..)来查看。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object, Array]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token regex">/regex-literal/i</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object, RegExp]&quot;</span>
</code></pre></div><p>上例中，数组的内部[[class]]属性值是“Array”, 正则表达式的值是“RegExp”。
多数情况下，对象的内部[[Class]]属性和创建该对象的内建原生构造函数相对应（如下），但并非总是如此。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object, Null]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object, Undefined]&quot;</span>
</code></pre></div><p>虽然Null()和Undefined()这样的原生构造函数并不存在，但是内部[[Class]]属性值仍然是&quot;Null&quot;和&quot;Undefined&quot;。</p> <p>其他基本类型值（如字符串、数字和布尔）的情况有所不同，通常称为“包装”</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object, String]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object, Number]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object, Number]&quot;</span>
</code></pre></div><h2 id="_2-封装对象包装"><a href="#_2-封装对象包装" class="header-anchor">#</a> 2. 封装对象包装</h2> <p>封装对象（object wrapper）扮演着十分重要的角色。</p> <p>由于基本类型值没有．length和．toString()这样的属性和方法，需要通过封装对象才能访问，此时JavaScript会自动为基本类型值包装（box或者wrap）一个封装对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;ABC&quot;</span>
</code></pre></div><h2 id="_3-拆封"><a href="#_3-拆封" class="header-anchor">#</a> 3. 拆封</h2> <p>如果想要得到封装对象中的基本类型值，可以使用valueOf()函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>

a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42&quot;</span>
b<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
c<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>在需要用到封装对象中的基本类型值的地方会发生隐式拆封.</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token string">''</span> <span class="token comment">// b的值为“abc”</span>
 <span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot;</span>
 <span class="token keyword">typeof</span> b <span class="token comment">// &quot;string&quot;</span>
</code></pre></div><h2 id="_4-原生函数作为构造函数"><a href="#_4-原生函数作为构造函数" class="header-anchor">#</a> 4. 原生函数作为构造函数</h2> <h3 id="_4-1-array"><a href="#_4-1-array" class="header-anchor">#</a> 4.1 Array(..)</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token comment">// [1, 2, 3]</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
b <span class="token comment">// [1, 2, 3]</span>
</code></pre></div><p>Array构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。</p> <p>这实非明智之举：一是容易忘记，二是容易出错。</p> <p>更为关键的是，数组并没有预设长度这个概念。这样创建出来的只是一个空数组，只不过它的length属性被设置成了指定的值。</p> <p>如若一个数组没有任何单元，但它的length属性中却显示有单元数量，这样奇特的数据结构会导致一些怪异的行为。</p> <p>而这一切都归咎于已被废止的旧特性（类似arguments这样的类数组）。</p> <p>对此，不同浏览器的开发控制台显示的结果也不尽相同，这让问题变得更加复杂。</p> <p>例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>length <span class="token comment">// 3</span>
a<span class="token punctuation">;</span>
</code></pre></div><p>a在Chrome中显示为[ undefined x 3 ]（目前为止），这意味着它有三个值为undefined的单元，但实际上单元并不存在（“空单元” 这个叫法也同样不准确）。</p> <p>从下面代码的结果可以看出它们的差别：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span>
b<span class="token punctuation">;</span>
c<span class="token punctuation">;</span>
</code></pre></div><p>我们可以创建包含空单元的数组，如上例中的c。</p> <p>只要将length属性设置为超过实际单元数的值，就能隐式地制造出空单元。</p> <p>另外还可以通过delete b[1]在数组b中制造出一个空单元。</p> <p>b在当前版本的Chrome中显示为[ undefined, undefined, undefined ]，而a和c则显示为[ undefined x 3 ]。</p> <p>是不是感到很困惑？</p> <p>更令人费解的是在当前版本的Firefox中a和c显示为[ , , , ]。</p> <p>仔细看来，这其中有三个逗号，代表四个空单元，而不是三个。</p> <p>Firefox在输出结果后面多添了一个，，原因是从<strong>ES5规范开始就允许在列表（数组值、属性列表等）末尾多加一个逗号（在实际处理中会被忽略不计）</strong>。</p> <p>所以如果你在代码或者调试控制台中输入[ , , , ]，实际得到的是[ , , ]（包含三个空单元的数组）。</p> <p>这样做虽然在控制台中看似令人费解，实则是为了让复制粘贴结果更为准确。</p> <p>更糟糕的是，上例中a和b的行为有时相同，有时又大相径庭：</p> <div class="language-js extra-class"><pre class="language-js"><code>a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span> <span class="token comment">// &quot;--&quot;</span>
b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span> <span class="token comment">// &quot;--&quot;</span>
a<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [undefined x 3]</span>
b<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// [0, 1, 2] </span>
</code></pre></div><p>a.map(..)之所以执行失败，是因为数组中并不存在任何单元，所以map(..)无从遍历。而join(..)却不一样，它的具体实现参考下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fakeJoin</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> connector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      str <span class="token operator">+=</span> connerctor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      str <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> str
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fakeJoin</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;--&quot;</span>
</code></pre></div><p>从中可以看出，join(..)首先假定数组不为空，然后通过length属性值来遍历其中的元素。</p> <p>而map(..)并不做这样的假定，因此结果也往往在预期之外，并可能导致失败。</p> <p>我们可以通过下述方式来创建包含undefined单元（而非“空单元”）的数组：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>length<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token comment">// [undefined, undefined, undefined]</span>
</code></pre></div><p>apply(..)是一个工具函数，适用于所有函数对象，它会以一种特殊的方式来调用传递给它的函数。</p> <p>总之，永远不要创建和使用空单元数组。</p> <h2 id="_4-2-object-、function-和regexp"><a href="#_4-2-object-、function-和regexp" class="header-anchor">#</a> 4.2 Object(..)、Function(..)和RegExp(..)</h2> <p>同样，除非万不得已，否则尽量不要使用Object(..)/Function(..)/RegExp(..)：</p> <p>强烈建议使用常量形式（如/^a＊b+/g）来定义正则表达式，这样不仅语法简单，执行效率也更高，</p> <p>因为JavaScript引擎在代码执行前会对它们进行预编译和缓存。</p> <p>与前面的构造函数不同，RegExp(..)有时还是很有用的，比如动态定义正则表达式时：</p> <p>正则表达式 new RegExp(&quot;pattern&quot;, &quot;flags&quot;)就能派上用场。</p> <h2 id="_4-3-symbol"><a href="#_4-3-symbol" class="header-anchor">#</a> 4.3 Symbol(..)</h2> <p>ES6中新加入了一个基本数据类型 ——符号（Symbol）。</p> <p><strong>符号是具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名。</strong></p> <p>该类型的引入主要源于ES6的一些特殊构造，此外符号也可以自行定义。</p> <h2 id="_4-5-原生原型"><a href="#_4-5-原生原型" class="header-anchor">#</a> 4.5 原生原型</h2> <p>原生构造函数有自己的．prototype对象，如Array.prototype、String.prototype等。</p> <p>这些对象包含其对应子类型所特有的行为特征。</p> <p>例如，将字符串值封装为字符串对象之后，就能访问String.prototype中定义的方法。</p> <p>根据文档约定，我们将String.prototype.XYZ简写为String#XYZ，对其他．prototype也同样如此。</p> <ul><li><p>String#indexOf(..) 在字符串中找到指定子字符串的位置。</p></li> <li><p>String#charAt(..) 获得字符串指定位置上的字符。</p></li> <li><p>String#substr(..)、String#substring(..)和String#slice(..) 获得字符串的指定部分。</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/javaScript/variable.html" class="prev">
        变量
      </a></span> <span class="next"><a href="/javaScript/grammar.html">
        语法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.735e6fcb.js" defer></script><script src="/assets/js/2.5cb423a9.js" defer></script><script src="/assets/js/27.484f76eb.js" defer></script>
  </body>
</html>
