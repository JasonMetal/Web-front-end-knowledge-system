<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Promise | 前端知识笔记</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.4b1b2517.css" as="style"><link rel="preload" href="/assets/js/app.735e6fcb.js" as="script"><link rel="preload" href="/assets/js/2.5cb423a9.js" as="script"><link rel="preload" href="/assets/js/17.bbebe80a.js" as="script"><link rel="prefetch" href="/assets/js/10.003b1904.js"><link rel="prefetch" href="/assets/js/11.e6c51907.js"><link rel="prefetch" href="/assets/js/12.97f760ec.js"><link rel="prefetch" href="/assets/js/13.16a079d8.js"><link rel="prefetch" href="/assets/js/14.ba729c8e.js"><link rel="prefetch" href="/assets/js/15.98bc4478.js"><link rel="prefetch" href="/assets/js/16.9c982a45.js"><link rel="prefetch" href="/assets/js/18.417f5bdf.js"><link rel="prefetch" href="/assets/js/19.c8b21384.js"><link rel="prefetch" href="/assets/js/20.6f51abd7.js"><link rel="prefetch" href="/assets/js/21.bf283b45.js"><link rel="prefetch" href="/assets/js/22.7be7440a.js"><link rel="prefetch" href="/assets/js/23.4742eeb2.js"><link rel="prefetch" href="/assets/js/24.d1d0ae86.js"><link rel="prefetch" href="/assets/js/25.05ddb5ef.js"><link rel="prefetch" href="/assets/js/26.f6b481a9.js"><link rel="prefetch" href="/assets/js/27.484f76eb.js"><link rel="prefetch" href="/assets/js/28.f775b8d4.js"><link rel="prefetch" href="/assets/js/29.d6781efc.js"><link rel="prefetch" href="/assets/js/3.3907cef8.js"><link rel="prefetch" href="/assets/js/30.82e04d36.js"><link rel="prefetch" href="/assets/js/31.d1b57a76.js"><link rel="prefetch" href="/assets/js/32.1d6b4690.js"><link rel="prefetch" href="/assets/js/33.8f0ed1db.js"><link rel="prefetch" href="/assets/js/4.9a0a833f.js"><link rel="prefetch" href="/assets/js/5.ce8228c5.js"><link rel="prefetch" href="/assets/js/6.77f60620.js"><link rel="prefetch" href="/assets/js/7.f2ca32c7.js"><link rel="prefetch" href="/assets/js/8.7ba72efb.js"><link rel="prefetch" href="/assets/js/9.3c298ae0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4b1b2517.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端知识笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/javaScript/type.html" class="sidebar-link">类型</a></li><li><a href="/javaScript/val.html" class="sidebar-link">值</a></li><li><a href="/javaScript/variable.html" class="sidebar-link">变量</a></li><li><a href="/javaScript/nativeFunction.html" class="sidebar-link">原生函数</a></li><li><a href="/javaScript/grammar.html" class="sidebar-link">语法</a></li><li><a href="/javaScript/asyn.html" class="sidebar-link">异步</a></li><li><a href="/javaScript/environment.html" class="sidebar-link">执行环境</a></li><li><a href="/javaScript/operating-mechanism.html" class="sidebar-link">运行机制</a></li><li><a href="/javaScript/closure.html" class="sidebar-link">闭包</a></li><li><a href="/javaScript/RAM.html" class="sidebar-link">内存问题</a></li><li><a href="/javaScript/object.html" class="sidebar-link">面向对象的程序设计</a></li><li><a href="/javaScript/Cross-domain.html" class="sidebar-link">跨域 与 Coment</a></li><li><a href="/javaScript/Simulation.html" class="sidebar-link">原理模拟实现</a></li><li><a href="/javaScript/advancedSkills.html" class="sidebar-link">高级技巧</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>读书笔记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h1> <p>回调表达异步程序和管理并发的两个主要缺陷：缺乏顺序性和可信任性。既然已经对问题有了充分的了解，那么现在是时候把注意力转向可以解决这个问题的模式了。</p> <p>我们首先想要解决掉的是控制反转问题，其中，信任很脆弱，也很容易失去。</p> <p>回忆一下，我们用回调函数来封装程序中的continuation,然后把回调交给第三方（甚至可能是外部代码），接着期待其能够调用回调，实现正确的功能。</p> <p>通过这种形式，我们表达的意思：这是将要作的事情，要在当前的步骤完成后发生。</p> <p>但是，如果我们能够把控制反转再反转回来呢？会怎么样呢？如果我们不把自己程序的continuation传给第三方，而是第三方给我们提供了解任务何时结束的能力，
然后由我们自己的代码来决定下一步做什么，那将会怎么样呢？</p> <p>这种范式就称为Promise。</p> <p>随着开发者和规范撰写者绝望地清理他们的代码和设计中由回调地狱引发的疯狂行为，Promise风暴已经开始席卷JavaScript世界。</p> <p>实际上，绝大多数JS/DOM平台新增的异步API都是基于Promise构建的。所以学习研究Promise应该是个好主意，你以为如何呢？！</p> <p>本章经常会使用“立即”一词，通常用来描述某个Promise决议（resolution）动作。</p> <p>但是，基本上在所有情况下，这个“立即”指任务队列行为（参见第1章）方面的意义，而不是指严格同步的现在。</p> <h2 id="_1-什么是promise"><a href="#_1-什么是promise" class="header-anchor">#</a> 1 什么是Promise</h2> <p>开发人员在学习新技术或模式时，通常第一步就是“给我看看代码”。对我们来说跳进去学习细节是自然的。</p> <p>但是事实证明，只有了解API会丢失很多抽象的细节。Promise属于这一类工具：通过某人使用它的方式，很容易分辨他是真正理解了这门技术，还是仅仅学习和使用API而已。</p> <p>所以，在展示Promise代码之前，我们先从概念上完整的解释Promise到底是什么。希望这能够更好地指导你今后将Promise理论集成到自己的异步流中。</p> <p>明确这一点之后，我们先来查看以下关于Promise定义的两个不同类。</p> <h3 id="_1-1-未来值"><a href="#_1-1-未来值" class="header-anchor">#</a> 1.1 未来值</h3> <p>设想一下这样一个场景：我们走到快餐店的柜台，点了一个芝士汉堡。我交给收银员1.47美元。通过下订单并付款，我已经发出了一个对某个值（就是那个汉堡）的请求。
我已经启动了一次交易。</p> <p>但是，通常我不能马上就得到这个汉堡。收银员会交给我某个东西来代替汉堡：一张带有订单号的收据，订单号就是一个IOU（I owe you，我欠你的）承诺（promise），保证了最终我会得到我的汉堡。</p> <p>在等待的过程中，我可以做点其他的事情，比如给朋友发个短信：“嗨，要来和我一起吃午饭吗？我正要吃芝士汉堡。”</p> <p>已经在想着未来的芝士汉堡了，尽管现在我还没有拿到手。我的大脑之所以可以这么做，是因为它已经把订单号当作芝士汉堡的占位符了。从本质上讲，这个占位符使得这个值不再依赖时间。这是一个未来值。</p> <p>终于，我听到服务员在喊“订单113”，然后愉快地拿着收据走到柜台，把收据交给收银员，换来了我的芝士汉堡。</p> <p>换句话说：<strong>一旦我需要的值准备好了，我就用我的承诺值换取这个值本身</strong></p> <p>但是，还可能有另一种结果。他们叫到了我的订单号，但当我过去拿芝士汉堡的时候，收银员满是歉意地告诉我：“不好意思，芝士汉堡卖完了。”除了作为顾客对这种情况感到愤怒之外，我们还可以看到未来值的一个重要特性：它可能成功，也可能失败。</p> <p>每次点芝士汉堡，我都知道最终要么得到一个芝士汉堡，要么得到一个汉堡包售罄的坏消息，那我就得找点别的当午饭了。</p> <h4 id="_1-1-1-现在值与将来值"><a href="#_1-1-1-现在值与将来值" class="header-anchor">#</a> 1.1.1 现在值与将来值</h4> <p>要把以上内容应用到代码里的话，前面的描述有点过于抽象，所以这里再具体说明一下。</p> <p>但在具体解释Primose的工作方式之前，先来推导通过我们已经理解的方式————回调————如何处理未来值。</p> <p>当编写代码要得到某个值的时候，比如通过数学计算，不管你有没有意识到，你已经对这个值做出了一些非常基本的假设，那就是，他已经是一个具体值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span> <span class="token comment">// NaN 因为x还没有设定</span>
</code></pre></div><p>运算x + y 假定了x 和 y 都已经设定。用术语简单地解释就是，这里我们假的x和y的值都是已决议的。</p> <p>期待运算符+本身能够神奇地检测并等待x和y都决议好（也就是准备好）再进行运算是没有意义的。如果有的语句现在完成，而有的语句将来完成，那就会在程序里引起混乱，
对不对？</p> <p>如果两条语句的任何一个（或全部）可能还没有完成，你怎么可能追踪这两条语句的关系呢？如果语句2依赖于语句1的完成，那么就只有两个输出：要么语句1马上完成，一切顺利执行；要么语句1还未完成，语句2因此也将会失败。</p> <p>学完第1章之后，如果这种情况你听起来很熟悉的话，非常好！</p> <p>让我们回到x + y这个算术运算。设想如果可以通过一种方式表达：“把x和y加起来，但如果它们中的任何一个还没有准备好，就等待两者都准备好。一旦可以就马上执行加运算。”</p> <p>可能你已经想到了回调。好吧，那么……</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">getX<span class="token punctuation">,</span> getY<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
    <span class="token function">getX</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">xVal</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        x <span class="token operator">=</span> xVal<span class="token punctuation">;</span>
        <span class="token comment">// 两个都准备好了？</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">cb</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span> <span class="token comment">// 发送和</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">getY</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">yVal</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        y <span class="token operator">=</span> yVal<span class="token punctuation">;</span>
        <span class="token comment">// 两个都准备好了？</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">cb</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span> <span class="token comment">// 发送和</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">add</span><span class="token punctuation">(</span>fetchX<span class="token punctuation">,</span> fetchY<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">sum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>先暂停片刻，认真思考一下这段代码的优美度（或缺少优美度，别急着喝彩）。</p> <p>尽管其中的丑陋不可否认，但这种异步模式体现出了一些非常重要的东西。</p> <p>在这段代码中，我们把x和y当作未来值，并且表达了一个运算add(..)。</p> <p>这个运算（从外部看）不在意x和y现在是否都已经可用。换句话说，它把现在和将来归一化了，因此我们可以确保这个add(..)运算的输出是可预测的。</p> <p>通过使用这个时间上一致的add(..)——从现在到将来的时间，它的行为都是一致的——大大简化了对这段异步代码的追踪。</p> <p>说得更直白一些就是，为了统一处理现在和将来，我们把它们都变成了将来，即所有的操作都成了异步的。</p> <p>当然，这个粗糙的基于回调的方法还有很多不足。要体会追踪未来值的益处而不需要考虑其在时间方面是否可用，这只是很小的第一步。</p> <h4 id="_1-1-2-promise值"><a href="#_1-1-2-promise值" class="header-anchor">#</a> 1.1.2 Promise值</h4> <p>本章后面一定会深入介绍很多Promise的细节，因此这里如果读起来有些困惑的话，不必担心。我们先来大致看一下如何通过Promise函数表达这个x + y的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">xPromise<span class="token punctuation">,</span> yPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Promise.all[..] 接受一个promise数组并返回一个新的promise</span>
    <span class="token comment">// 这个新的promise等待数组中的所有promise完成</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>xPromise<span class="token punctuation">,</span> yPromise<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token comment">// 这个promise决议之后，我们取得收到的x,y的值加载一起</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">values</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// values是来自之前决议的promise消息数组</span>
        <span class="token keyword">return</span> values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// fetchX() 和 fetchY() 返回相应值的promise，可能已经就绪，也可能以后就绪</span>

<span class="token function">add</span><span class="token punctuation">(</span>fetchX<span class="token punctuation">,</span> fetchY<span class="token punctuation">)</span>
<span class="token comment">// 我们得到一个这两个数组和的promise</span>
<span class="token comment">// 现在链式调用then(..)来等待返回promise的决议</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">sum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这更简单</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这段代码中有两层Promise。</p> <p>fetchX()和fetchY()是直接调用的，它们的返回值（promise!）被传给add(..)。</p> <p>这些promise代表的<strong>底层值的可用时间可能是现在或将来</strong>，但不管怎样，<strong>promise归一保证了行为的一致性</strong>。我们可以按照不依赖于时间的方式追踪值X和Y。它们是未来值。</p> <p>第二层是add(..)(通过promise.all[..]) 创建并返回的promise。我们通过then(..)等待这个promise。add(..)运算完成后，未来值sum就准备好了，可以打印出来。
我们把等待未来值X和Y的逻辑隐藏在add(..)内部。</p> <p>就像芝士汉堡订单一样，Promise的决议结果可能是拒绝而不是完成。拒绝值和完成的Promise不一样：完成值总是编程给出的，而拒绝值，通常称为拒绝原因（rejection reason），可能是程序逻辑直接设置的，也可能是从运行异常隐式得出的值。</p> <p>通过Promise，调用then(..)实际上可以接受两个函数，第一个用于完成情况（如前所示），第二个用于拒绝情况：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">fetchX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fetchY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    <span class="token comment">// 完成处理函数</span>
    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">sum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> sum <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 拒绝处理函数</span>
    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">loh</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 烦！</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><p>如果在获取X或Y的过程中出错，或者在加法过程中出错，add(..)返回的就是一个被拒绝的promise，传给then(..)的第二个错误处理回调就会从这个promise中得到拒绝值。</p> <p>从外部看，由于Promise封装了依赖于时间的状态——等待底层值的完成或拒绝，所以Promise本身是与时间无关的。因此，Promise可以按照可预测的方式组成（组合），而不用关心时序或底层的结果。</p> <p>另外，一旦Promise决议，它就永远保持在这个状态。此时它就成为了不变值（immutable value），可以根据需求多次查看。</p> <p>这是关于Promise需要理解的最强大也最重要的一个概念。经过大量的工作，你本可以通过丑陋的回调组合专门创建出类似的效果，但这真的不是一个有效的策略。
特别是你不得不一次又一次的重复操作。</p> <p>Promise是一种封装和组合未来值的易用复用的机制。</p> <h3 id="_1-2-完成事件"><a href="#_1-2-完成事件" class="header-anchor">#</a> 1.2 完成事件</h3> <p>如前所述，单独的Promise展示了未来值的特性。但是，也可以从另一个角度看待Promise的决议：一种在异步任务中作为两个或更多步骤的流程控制机制，时序上的
this-then-that。</p> <p>假定要调用一个函数foo(..)执行任务。我们不知道也不关心它的任何细节。这个函数可能立即完成任务，也能需要一段时间才能完成。</p> <p>我们只需要知道foo(..)什么时候结束，这样就可以进行下一个任务。换句话说，我们想要通过某种方式在foo（..）完成的时候得到通知，以便可以继续下一步。</p> <p>在经典的JS风格中，如果需要侦听某个通知，你可能会想到事件。因此，可以把对通知的需求重新组织为对foo(..)发生的一个完成事件的侦听。</p> <p>使用回调的话，通知就是任务（foo(..)）调用的回调。而使用Promise的话，我们把这个关系反转了过来，侦听来自foo(..)的事件，然后在得到通知的时候，根据情况继续。</p> <p>首先，考虑以下伪代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 开始做点可能耗时的事情</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token function">on</span><span class="token punctuation">(</span>foo<span class="token string">&quot;completion&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 可以进行下一步了</span>
<span class="token punctuation">}</span>
<span class="token function">on</span><span class="token punctuation">(</span>foo <span class="token string">&quot;error&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 啊，foo(..)中出错了</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们调用foo(..),然后建立两个事件侦听器，一个用于“completion”，一个用于“error”————foo(..)调用的两个可能结果。从本质上将，foo(..)并不需要了解调用
代码订阅这些事件，这样就很好地实现了关注点分离。</p> <p>遗憾的是，这样的的代码需要JS环境提供某种魔法，而这种环境并不存在（实际上有点不实际）。以下是在JS中更自然的表达方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 开始做点耗时的工作</span>
    <span class="token comment">// 构建一个listener事件通知处理对象返回</span>
    <span class="token keyword">return</span> listener<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> evt <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

evt<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;completion&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 可以进行下一步了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
evt<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;err&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 出错了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>foo(..)显示创建并返回一个事件订阅对象，调用代码得到这个对象，并且在其上注册了两个事件处理函数。</p> <p>相对于面向回调的代码，这里的反转是显而易见的，而且这也是有意为之。这里没有把回调传给foo(..),</p> <p>而是返回一个名为evt的事件注册对，由它来接受回调。</p> <p>如果你回想一下第2章的话，应该还记得回调本身就表达了一种控制反转。</p> <p>所以对回调模式的反转实际上是对反转的反转，或者称为反控制反转——把控制返还给调用代码，这也是我们最开始想要的效果。</p> <p>一个重要的好处是，可以把这个事件侦听对象提供给代码中多个独立的部分；在foo(..)完成的时候，它们都可以独立地得到通知，以执行下一步：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> evt <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//让bar(..)侦听foo(..)的完成</span>
<span class="token function">bar</span><span class="token punctuation">(</span>evt<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//并且让baz(..)侦听foo(..)的完成。</span>
<span class="token function">baz</span><span class="token punctuation">(</span>evt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>对控制反转的恢复实现了更好的关注点分离，其中bar(..)和baz(..)不需要牵扯到foo(..)的调用细节。</p> <p>类似地，foo(..)不需要知道或关注bar(..)和baz(..)是否存在，或者是否在等待foo(..)的完成通知。</p> <p>从本质上说，evt对象就是分离的关注点之间一个中立的第三方协商机制。</p> <p>Promise“事件”</p> <p>你可能已经猜到，事件侦听对象evt就是Promise的一个模拟。</p> <p>在基于Promise的方法中，前面的代码片段会让foo(..)创建并返回一个Promise实例，而且这个Promise会被传递到bar(..)和baz(..)。</p> <p>考虑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 开始做一些可能耗时的工作</span>
    <span class="token comment">// 构造并返回一个promise</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 最终调用resolve() 或者 reject()</span>
        <span class="token comment">// 这是这个promise的决议回调</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">bar</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">baz</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
</code></pre></div><p>你可能会猜测bar(..)和baz(..)的内部实现或许如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">fooPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 侦听foo(..)完成</span>
    fooPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
        <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// foo(..)已经完毕，所以执行bar(..)的任务</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 出错</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Promise决议并不一定要像前面将Promise看作为未来值查看时一样会涉及发送消息。它也可以只作为一种流程控制信号，就像前面这段代码的用法一样。</p> <p>另外一种实现方式是：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">oppsBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> oopsBar<span class="token punctuation">)</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>baz<span class="token punctuation">,</span> oopsBar<span class="token punctuation">)</span>
</code></pre></div><p>这里没有把promise传给bar(..)和baz(..),而是使用prmise控制bar和baz何时执行，如果执行的话。最主要的区别在于错误处理部分。</p> <p>在第一段代码的方法里，不论foo(..)成功与否，bar(..)都会被调用。</p> <p>并且如果收到了foo(..)失败的通知，它会亲自处理自己的回退逻辑。显然，baz(..)也是如此。</p> <p>在第二段代码中，bar(..)只有在foo(..)成功时才会被调用，否则就会调用oppsBar(..)。baz(..)也是如此。</p> <p>这两种方法本身并谈不上对错，只是各自适用于不同的情况。</p> <p>不管哪种情况，都是从foo(..)返回的promise p来控制接下来的步骤。</p> <p>另外，两段代码都以使用promise p调用then(..)两次结束。</p> <p>这个事实说明了前面的观点，就是Promise（一旦决议）一直保持其决议结果（完成或拒绝）不变，可以按照需要多次查看。一旦p决议，不论是现在还是将来，下一个步骤总是相同的。</p> <h2 id="_2-具有then方法的鸭子类型"><a href="#_2-具有then方法的鸭子类型" class="header-anchor">#</a> 2 具有then方法的鸭子类型</h2> <p>在Promise领域，一个重要的细节是如何确定某个值是不是真正的Promise。或者更直接的说，它是不是一个行为类似于Promise的值？</p> <p>既然Promise是通过 new Promise(..)语法创建的，那你可能就认为可以通过p instanceof Promise 来检查。但遗憾的是，这不足以作为检查方法，原因有很多。</p> <p>其中最主要的是，Promise值可能是从其他浏览器窗口（iframe等）接收到的。这个浏览器窗口自己的Promise可能和当前窗口的/frame不同，因此这样的检查无法是被
Promise实例。</p> <p>还有，库或框架可能会选择实现自己的Promise，而不是使用原生ES6 Promise实现。实际上，很有可能你是在早期根本没有Promise实现的浏览器中使用由库提供的Promise。</p> <p>因此，识别Promise（或者行为类似于Promise的东西）就是定义某种称为thenable的东西，将其定义为任何具有then(..)方法的对象和函数。我们认为，任何这样的值就是Promise一致的thenable。</p> <p>根据一个值的形态（具有哪些属性）对这个值的类型做出一些假定。</p> <p>这种类型检查（type check）一般用术语鸭子类型（duck typing）来表示——“如果它看起来像只鸭子，叫起来像只鸭子，那它一定就是只鸭子”（参见本书的“类型和语法”部分）。于是，对thenable值的鸭子类型检测就大致类似于：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> p <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> p <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> p<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 假定这个一个thenable!</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不是thenable</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除了在多个地方实现这个逻辑有点丑陋之外，其实还有一些更深层次的麻烦。</p> <p>如果你试图使用恰好有then(..)函数的一个对象或函数值完成一个Promise，但并不希望它被当作Promise或thenable，那就有点麻烦了，因为它会自动被识别为thenable，并被按照特定的规则处理.</p> <p>即使你并没有意识到这个值有then(..)函数也是这样。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 让v[[Prototype]]-link到o</span>

<span class="token keyword">var</span> v <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>

v<span class="token punctuation">.</span>someStuff <span class="token operator">=</span> <span class="token string">&quot;cool&quot;</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span>toherStuff <span class="token operator">=</span> <span class="token string">&quot;not so cool&quot;</span><span class="token punctuation">;</span>

v<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;then&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p>v看起来根本不像Promise或者thenable。它只是一个具有一些属性的简单对象。你可能只是想要像对其他对象一样发送这个值。</p> <p>但你不知道的是，v还[[Prototype]]连接到了另一个对象o,而后者恰好有一个then(..)属性。所以thenable鸭子类型检测会把v认作一个thenable。</p> <p>甚至不需要直接有意支持的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> v1 <span class="token operator">=</span> <span class="token punctuation">{</span> hello<span class="token operator">:</span> <span class="token string">&quot;world&quot;</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> v2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>v1和v2 都会被认作thenable。如果有任何其他代码无意或恶意给Object.prototype，Array.prototy或其他原生原型添加then(..)。</p> <p>但是别忘了，在ES6之前，社区已经有一些著名的非Promise库恰好有名为then(..)的方法。这些库中有一部分选择了重命名自己的方法以避免冲突（这真糟糕！）。而其他的那些库只是因为无法通过改变摆脱这种冲突，就很不幸地被降级进入了“与基于Promise的编码不兼容”的状态。</p> <p>标准决定劫持之前未保留的——听起来是完全通用的——属性名then。这意味着所有值（或其委托），不管是过去的、现存的还是未来的，都不能拥有then(..)函数，不管是有意的还是无意的；否则这个值在Promise系统中就会被误认为是一个thenable，这可能会导致非常难以追踪的bug。</p> <h2 id="_3-promise-信任问题"><a href="#_3-promise-信任问题" class="header-anchor">#</a> 3 Promise 信任问题</h2> <p>前面已经给出了两个很强的类比，用于解释Promise在不同方面为我们的异步代码。但如果止步于此的话，我们就错过了Promise模式构建的可能最重要的特性：信任。</p> <p>未来值和完成事件这两个类比在我们之前探讨的代码模式中很明显。但是，我们还不能一眼就看出Promise为什么以及如何用于解决2.3节列出的所有控制反转信任问题。稍微深入探究一下的话，我们就不难发现它提供了一些重要的保护，重新建立了第2章中已经毁掉的异步编码可信任性。</p> <p>先回顾一下只用回调编码的信任问题。把一个回调传入工具foo(..)时可能出现如下问题：</p> <ul><li>调用回调过早</li> <li>调用回调过晚</li> <li>调用回调次数过少或过多</li> <li>未能传递传递需的环境和参数</li> <li>吞掉可能出现的错误和异常</li></ul> <p>Promise的特性就是专门用来为这些问题提供一个有效的可复用的答案。</p> <h3 id="_3-1-调用过早"><a href="#_3-1-调用过早" class="header-anchor">#</a> 3.1 调用过早</h3> <p>这个问题主要就是担心代码是否会引入类似Zalgo这样的副作用。
在这类问题中，一个任务有时同步完成，有时异步完成，这可能会导致竞态条件。</p> <p>根据定义，Promise就不必担心这种问题，因为即使是立即完成的Promise（类似于new Promise(function(resolve){ resolve(42); })）也无法被同步观察到。</p> <p>也就是说，<strong>对一个Promise调用then(..)的时候，即使这个Promise已经决议，提供给then(..)的回调也总会被异步调用</strong></p> <h3 id="_3-2-调用过晚"><a href="#_3-2-调用过晚" class="header-anchor">#</a> 3.2 调用过晚</h3> <p>和前面类似，Promise创建对象调用resolve(..)或者reject(..)时，这个Promise的then(..)<strong>注册的观察回调</strong>就会被<strong>自动调度</strong>。可以确信，这些被调度的回调在下一个
异步事件点上一定会被触发。</p> <p>同步查看是不可能的，所以一个同步任务链无法以这种方式运行来实现按照预期有效延迟另一个回调的发生。也就是说，一个Promise决议后，这个Promise上所有的通过then(..)注册的回调都会在下一个异步时机点上依次被立即调用（再次提醒，请参见1.5节）。这些回调中的任意一个都无法影响或延误对其他回调的调用。</p> <div class="language-js extra-class"><pre class="language-js"><code>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>A B C</p> <p>这里，&quot;C&quot;无法打断或抢占&quot;B&quot;，这是因为Promise的运作方式。</p> <p><strong>Promise调度技巧</strong></p> <p>但是，还有很重要的一点需要指出，有很多调度的细微差别。在这种情况下，两个独立的Promise上链接的回调相对顺序无法靠预测。</p> <p>如果两个promise p1和p2都已经决议，那么p1.then(..);p2.then(..)应该最终会先调用p1的回调，然后是p2的那些。但还有一些微妙的场景
可能不是这样的，比如以下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
pe<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// A B 而不是像你认为的那样BA</span>
</code></pre></div><p>后面我们会深入介绍，但目前你可以看到，p1不是用立即值而是用另一个Promise p3决议，后者本身决议值为“B”。规定的行为是把p3展开到p1,但是是异步展开。
所以，在异步队列中，p1的回调排在p2后面。</p> <p>要避免这样的细微区别带来的噩梦，永远不要依赖于不同的Promise间回调的顺序和调度。实际上，好的编码实际方案根本不会让多个回调的顺序有丝毫影响，可能的话
就要避免。</p> <h3 id="_3-3-回调未调用"><a href="#_3-3-回调未调用" class="header-anchor">#</a> 3.3 回调未调用</h3> <p>这个问题很常见，Promise可以通过几种途径解决。</p> <p>首先，没有任何东西（甚至JS错误）能阻止Promise向你通知它的决议（如果它决议的化）。如果你对一个Promise注册了一个完成回调和一个拒绝回调，
那么Promise在决议时总是会调用其中的一个。</p> <p>当然，如果你的回调函数本身包括JS错误，那可能就会看不到你期望的结果，但实际上回调还是被调用了。后面我们会介绍如何在回调错误时得到通知，
因为就连这些错误也不会被吞掉。</p> <p>但是，如果Promise本身永远不会被决议呢？即使这样，Promise也提供了解决方案，其使用了一种称为竞态的高级抽象机制：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 用于超时一个Promise的工具</span>
<span class="token keyword">function</span> <span class="token function">timeoutPromise</span><span class="token punctuation">(</span><span class="token parameter">delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&quot;Timeout!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 设置foo()超时</span>
Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">timeoutPromise</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>关于这个Promise超时模式还有更多细节需要考量，后面会深入讨论。</p> <p>很重要的一点是，我们可以保证一个foo()有一个输出符号，防止其永久挂住程序。</p> <h3 id="_3-4-调用次数过多或过少"><a href="#_3-4-调用次数过多或过少" class="header-anchor">#</a> 3.4 调用次数过多或过少</h3> <p>根据定义，回调被调用的正确次数为1.“过少”的情况就是调用为0次，前面解决过的“未被”调用的是同一种情况</p> <p>“过多”的情况很容易理解。Promise的定义方式使得它只能被决议一次。如果处于某种原因，Promise创建代码试图
调用resolve(..)或reject(..)多次，或者试图两者都调用，那么这个Promise将只会接受第一次决议，并默默地忽略
任何后续调用。</p> <p>由于Promise只能被决议一次，所以任何通过then(..)注册的回调只会被调用一次。</p> <p>当然，如果你把同一个回调注册了不止一次，那么它被调用次数和注册次数一样，响应只会被调用一次，但这个保证并不能
预防你搬起石头砸自己的脚。</p> <h3 id="_3-5-未能传递参数-环境值"><a href="#_3-5-未能传递参数-环境值" class="header-anchor">#</a> 3.5 未能传递参数/环境值</h3> <p>Promise 至多只能有一个决议值（完成或拒绝）。</p> <p>如果你没有用任何值显示决议，那么这个值是undefined.这是JS常见的处理方式。但不管这个值是什么，无论当前或将来，它都会
被传给所有注册的回调。</p> <p>还有一点需要清楚：如果使用多个参数调用resolve(..)或reject(..),第一个参数之后的所有参数都会被忽略。这看起来似乎违背了
我们前面介绍的保证，但实际上没有，因为这是对Promise机制的无效使用。对于这组API的其他无效使用，也是类似的保护处理，所有
这里的Promise的行为是一致的。</p> <p>如果要传递多个值，你就必须要把它们封装在单个值中传递，比如通过一个数组或对象。</p> <p>对环境来说，js中的函数总是保持其定义所在的作用域的闭包，所以它们当然可以继续访问你提供的环境状态。当然，对于只能回调的设计也是
这样，因此并不是Promise特有的优点————但不管怎么样，这仍是我们可以依靠的一个保证。</p> <h3 id="_3-6-吞掉错误或异常"><a href="#_3-6-吞掉错误或异常" class="header-anchor">#</a> 3.6 吞掉错误或异常</h3> <p>基本上，这部分是上个要点的再次说明。如果拒绝一个Promise并给出一个理由，这个值就会被传给拒绝回调。</p> <p>不过在这里还有更多的细节需要研究。如果在Promise的创建过程中或查看其决议结果过程中的任何时间点上出现一个JS异常。比如一个TypeError或ReferenceError，
那这个异常会被捕捉，并且使这个Promise被拒绝。</p> <p>举例来说：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// foo未定义，所以会出错</span>
    <span class="token function">resove</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token comment">// 永远不会到这</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>foo.bar()中发生的JavaScript异常导致了Promise拒绝，你可以捕捉并对其作出响应。</p> <p>这是一个重要的细节，因为其有效解决了另外一个潜在的Zalgo风险，即出错可能会引起同步响应，而不出错则会是异步的。Promise甚至把JavaScript异常也变成了异步行为，进而极大降低了竞态条件出现的可能。</p> <p>但是，如果Promise完成后在查看结果时（then(..)注册的回调中）出现了JavaScript异常错误会怎样呢？即使这些异常不会被丢弃，但你会发现，对它们的处理方式还是有点出乎意料，需要进行一些深入研究才能理解：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token comment">//永远不会到这里</span>
<span class="token punctuation">}</span>， <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_3-7-是可信任的promise吗？"><a href="#_3-7-是可信任的promise吗？" class="header-anchor">#</a> 3.7 是可信任的Promise吗？</h3> <p>为什么Promise就比单纯使用回调更值得信任呢？</p> <p>关于Promise的很重要但是常常被忽略的一个细节是，Promise对这个问题已经有一个解决方案。
包含在原生ES6 Promise实现中的解决方案就是Promise.resolve(..)。</p> <p>如果向Promise.resolve(..)传递一个非Promise、非thenable的立即值，就会得到一个用这个值填充的promise。下面这种情况下，promise p1和promise p2的行为是完全一样的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>而如果向 Promise.resolve()传递一个真正的promsie, 就会返回同一个promise。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>

p1 <span class="token operator">===</span> p2 <span class="token comment">// true</span>
</code></pre></div><p>如果向Promise.resolve(..)传递一个非Promise的thenable值，前者会试图展开这个值，而且展开过程会持续到提取出一个具体的非类Promise的最终值。</p> <p>考虑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">cb</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">fulffilled</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>Promise.resolve(..)可以接受任何thenable，将其解封为它的非thenable值。</p> <p>从Promise. resolve(..)得到的是一个真正的Promise，是一个可以信任的值。</p> <p>如果你传入的已经是真正的Promise，那么你得到的就是它本身，所以通过Promise.resolve(..)过滤来获得可信任性完全没有坏处。</p> <p>Promise.resolve(..)提供了可信任的Promise封装工具，可以链接使用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="_4-链式流"><a href="#_4-链式流" class="header-anchor">#</a> 4 链式流</h2> <p>Promise固有行为特性：</p> <ul><li><p>每次你对Promise调用then(..)，它都会创建并返回一个新的Promise，我们可以将其链接起来；</p></li> <li><p>不管从then(..)调用的完成回调（第一个参数）返回的值是什么，它都会被自动设置为被链接Promise（第一点中的）的完成。</p></li></ul> <p>没有消息传递的延迟序列对于Promise流程控制来说并不是一个很有用的示例。我们来考虑如下这样一个更实际的场景。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 假定工具ajax({url} , {callback}) 存在</span>

<span class="token keyword">function</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token string">'heep'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token string">&quot;http2&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_5-错误处理"><a href="#_5-错误处理" class="header-anchor">#</a> 5 错误处理</h2> <h2 id="_6-promise模式"><a href="#_6-promise模式" class="header-anchor">#</a> 6 Promise模式</h2> <h2 id="_7-promise-api概述"><a href="#_7-promise-api概述" class="header-anchor">#</a> 7 Promise API概述</h2> <h3 id="_7-1-new-promise-构造器"><a href="#_7-1-new-promise-构造器" class="header-anchor">#</a> 7.1 new Promise(..)构造器</h3> <h3 id="_7-2-promise-resolve-和promise-reject"><a href="#_7-2-promise-resolve-和promise-reject" class="header-anchor">#</a> 7.2 Promise.resolve(..)和Promise.reject(..)</h3> <h3 id="_7-3-then-和catch"><a href="#_7-3-then-和catch" class="header-anchor">#</a> 7.3 then(..)和catch(..)</h3> <h3 id="_7-4-promise-all-和promise-race"><a href="#_7-4-promise-all-和promise-race" class="header-anchor">#</a> 7.4 Promise.all([ .. ])和Promise.race([ .. ])</h3> <h2 id="_8-promise局限性"><a href="#_8-promise局限性" class="header-anchor">#</a> 8 Promise局限性</h2> <h3 id="_8-1-顺序错误处理"><a href="#_8-1-顺序错误处理" class="header-anchor">#</a> 8.1 顺序错误处理</h3> <p>Promise设计中的一个局限性，即Promise链中的错误容易被忽略。</p> <p>如果链中的任何一个步骤事实上进行了自身的错误处理（可能以隐藏或抽象的不可见的方式），那你的handleErrors(..)就不会得到通知。</p> <p>这可能是你想要的——毕竟这是一个“已处理的拒绝”——</p> <p>完全不能得到（对任何“已经处理”的拒绝错误的）错误通知也是一个缺陷，它限制了某些用例的功能。</p> <h3 id="_8-2-单一值"><a href="#_8-2-单一值" class="header-anchor">#</a> 8.2 单一值</h3> <h3 id="_8-3-单决议"><a href="#_8-3-单决议" class="header-anchor">#</a> 8.3 单决议</h3> <h3 id="_8-4-惯性"><a href="#_8-4-惯性" class="header-anchor">#</a> 8.4 惯性</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Promise<span class="token punctuation">.</span>wrap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Promise<span class="token punctuation">.</span><span class="token function-variable function">warp</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>
                    <span class="token keyword">null</span><span class="token punctuation">,</span> 
                    args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                            <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span><span class="token punctuation">)</span>
                <span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_8-5-无法取消的promise"><a href="#_8-5-无法取消的promise" class="header-anchor">#</a> 8.5 无法取消的Promise</h3></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.735e6fcb.js" defer></script><script src="/assets/js/2.5cb423a9.js" defer></script><script src="/assets/js/17.bbebe80a.js" defer></script>
  </body>
</html>
