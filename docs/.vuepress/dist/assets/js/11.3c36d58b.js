(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{114:function(t,o,s){"use strict";s.r(o);var a=s(0),l=Object(a.a)({},(function(){var t=this,o=t.$createElement,s=t._self._c||o;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"请描述react-hooks-组件与class组件的差异，及各自性能优化的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请描述react-hooks-组件与class组件的差异，及各自性能优化的方法"}},[t._v("#")]),t._v(" 请描述react hooks 组件与class组件的差异，及各自性能优化的方法")]),t._v(" "),s("ol",[s("li",[t._v("组件的差异")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("class组件之间复用状态逻辑很难，使用hook从中提取状态逻辑，使得这些逻辑可以复用，"),s("code",[t._v("hook 可以在不改变组件结构的情况下复用状态逻辑")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("class组件，起初可能会比较简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期都包含这个不同的逻辑。比如说，组件常常会在componentDidMount、componentUpdate获取\n数据。但是同一个 "),s("code",[t._v("componentDidMount")]),t._v("可能包含很多的逻辑，如设置监听，而后还要在compoenntWillUnmount中清除。这样子会导致相互关联的代码被拆开，无关的代码却放在一起。如此很容易产生bug，并且导致逻辑不一致。 而HOOK将组件拆分成更新颗粒度的函数（比如设置订阅函数或者请求数据），并非按照生命周期划分。")])]),t._v(" "),s("li",[s("p",[t._v("难以理解的 class，学习React是class的一大屏障，要去关注JavaScript 中 this 的工作方式，而hook则不需要去关注。")])])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("hooks性能优化方法")])]),t._v(" "),s("li",[s("p",[t._v("class性能优化方法")])])])])}),[],!1,null,null,null);o.default=l.exports}}]);