# 数据类型
   ES标准规定了8种数据类型，其中有7种简单数据类型：`Undefind`、`Null`、`Boolean`、`Number`、`String`、`Symbol`、`BigInt`。
   以及1种复杂数据类型：`Object`

   ## Undefined 类型
   Undefined 类型只有一个值，即特殊的 undefined。未初始化的变量会自动被赋予undefined值，但是显示地初始化变量依然是明智的选择。
   ## Null 类型
   Null 类型只有一个值，null。从逻辑角度来看，null值表示一个空对象指针，而这也正是typeof操作符检测null值时返回“object”的原因。

   如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。
   这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的应用，如下面的例子
   ```js
    if (car !== null) {

    }
   ```
   实际上，undefined值是派生自null值的，因此ECMA-262规定它们的相等性测试要返回true;
   ```js
    alter(null == undefined); // true
   ```
   ## Boolean 类型
   Boolean 类型时ES中使用最多的一种类型，该类型只有两个字面量：true和false。
   ## String类型
   **1. 字符串** 

   String 数据类型包含一些特殊的字符字面量，也叫转移序列，用于表达非打印字符，或者具有其他用途的字符
   
   **2. 字符串** 
   字符串的特点，ES中的字符串是不可变的，也就说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要摧毁原来的字符串，
   然后再用另一个包含新值的字符串填充该变量，例如：
   ```js
     var lang = 'java';
     lang = lang + "Script";
   ```
   ## Number类型

   ES中Number类型使用`IEEE754`标准来表示整数和浮点数值。
   `IEEE754`：全称IEEE二进制浮点数算术标准，定义了表示浮点数的格式等内容。

   在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、
   延伸单精确度、延伸双精确度。像ES采用的就是双精确度，也就是说，会用64位字节来存储
   一个浮点数。

  
   ### 浮点数值
   所谓浮点数值，就是该数值种必须包含一个小数点，并且小数点后面必须至少有一位数字。
   浮点数值得最高精度是17位小数。
   
   ### 0.1+0.2为什么不等于0.3？
  
   ***浮点数转二进制***

   1020二进制：1111111100
   ```
   1020 = 1020 = 1 * 2^9 + 1 * 2^8 + 1 * 2^7 
   + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0
   ```

   0.75二进制
   ```
   0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...
   ```
   因为使用的是二进制，abcd……的值的是 0 或 1。两边不停的 * 2 算出，解法如下：
   ```
    0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4...
    1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3... (所以 a = 1)
    0.5 = b * 2^-1 + c * 2^-2 + d * 2^-3...
    1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3... (所以 b = 1)
  ```
   0.75 用二进制表示就是 0.ab，也就是 0.11
   
   0.1二进制

   ```
    0.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...
    0 + 0.2 = a * 2^0 + b * 2^-1 + c * 2^-2 + ...   (a = 0)
    0 + 0.4 = b * 2^0 + c * 2^-1 + d * 2^-2 + ...   (b = 0)
    0 + 0.8 = c * 2^0 + d * 2^-1 + e * 2^-2 + ...   (c = 0)
    1 + 0.6 = d * 2^0 + e * 2^-1 + f * 2^-2 + ...   (d = 1)
    1 + 0.2 = e * 2^0 + f * 2^-1 + g * 2^-2 + ...   (e = 1)
    0 + 0.4 = f * 2^0 + g * 2^-1 + h * 2^-2 + ...   (f = 0)
    0 + 0.8 = g * 2^0 + h * 2^-1 + i * 2^-2 + ...   (g = 0)
    1 + 0.6 = h * 2^0 + i * 2^-1 + j * 2^-2 + ...   (h = 1)
    ....
   ```
   0.1用二进制表示就是0.00011001100110011……

  ***浮点数的存储***

  IEEE754标准认为，浮点数 (Value)可表示为 `Value = sign * exponent * fraction`，简单理解就是科学计数法。
  
  比如 -1020：
  ```
    用科学计数法表示:  -1 * 10^3 * 1.02。
    sign: -1，exponent: 10^3，fraction: 1.02。
  ```
  再比如：以 0.1 的二进制 0.00011001100110011……。

  ```
    用科学计数法表示：1 * 2^-4 * 1.1001100110011…
    sign：1，exponent：2^-4，fraction：1.1001100110011……
  ```

  **只做二进制科学计数法的表示时**：`Value = (-1)^S * (1 + Fraction) * 2^E`

  `(-1)^S`: 
  
  表示符号位，当 S = 0，V 为正数；当 S = 1，V 为负数。

  `(1 + Fraction)`: 
  
  所有的浮点数都可以表示为 1.xxxx * 2^xxx 的形式，
  前面的一定是 1.xxx，那干脆我们就不存储这个 1 了，
  直接存后面的 xxxxx 好了，这也就是 Fraction 的部分。

  `2^E`: 
  ```
  1020.75:
  二进制数: 1111111100.11，
  二进制科学计数法： 1 * 1.11111110011 * 2^9，E 的值就是 9，
  ```

  ```
  0.1: 
  二进制科学计数法: 1 * 1.1001100110011…… * 2^-4，E 的值就是 -4，
  ```


  E 既可能是负数，又可能是正数，
  
  **该怎么储存 E 呢？**

  假如用 8 位字节来存储 E 这个数：正数值的范围是 0 ~ 254；正负数值的范围是 -127~127。把要存储的数字加上 127，当存 -127 的时候，存 0；当存 127 的时候，存 254，当取值时减去 127。

  实际存储： E + bias。8 个字节的时候，bias 就是 127。要存储一个浮点数： S + Fraction + (E + bias) 。
  
  要分配多少个字节位来存储这些数呢？IEEE754 给出了标准：1 位存储 S，0 表示正数，1 表示负数。用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。用 52 位存储 Fraction。以0.1为例：
  
  ```

  `科学计数法`: 1 * 1.1001100110011…… * 2^-4 

  `Sign`: 0

  `E + bias`: -4 + 1023 = 1019

  1019 用二进制表示是 1111111011

  Fraction 是 1001100110011……

  ```

  对应 64 个字节位的完整表示就是：
  ```
  0 01111111011 1001100110011001100110011001100110011001100110011010
  ```
  同理, 0.2 表示的完整表示是：
  ```
  0 01111111100 1001100110011001100110011001100110011001100110011010
  ```
  ***浮点数的运算***

  五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。

  **对阶**

  0.1 是 1.1001100110011…… * 2^-4，阶码是 -4
  
  0.2 就是 1.10011001100110...* 2^-3，阶码是 -3
  
  两个阶码不同，先调整, 小阶对大阶

  ```
  0.1 -4 调到 -3: 0.11001100110011…… * 2^-3
  ```

  **尾数运算**

  ```
  0.1100110011001100110011001100110011001100110011001101
  + 1.1001100110011001100110011001100110011001100110011010
  ————————————————————————————————————————————————————————
  10.0110011001100110011001100110011001100110011001100111
  ```

  **规格化**
  ```
  1.0011001100110011001100110011001100110011001100110011(1) * 2^-2
  ```
  **舍入处理**

  括号里的 1 超出了范围，要被舍弃（0 舍 1 入）。
  ```
  1.0011001100110011001100110011001100110011001100110100 * 2^-2
  ```

  **结果存成 64 位**
  ```
  0 01111111101 0011001100110011001100110011001100110011001100110100
  ```
  转换为10进制数：0.30000000000000004440892098500626

  **结论**

  因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3
  
   ## 类型检测

   ### 检测基本类型：
   检测变量的基本类型使用`typeof`,除了`null`都可以显示正确的类型。
   
   使用`typeof`检查`null`值会返回`object`。因为从逻辑角度看，`null`表示一个空对象指针。 

   `typeof`检测函数时，会返回“function。

   ### 检测引用类型：
   检测变量的引用类型使用: `instanceof`。

   检测某个对象是否为数组使用: `Array.isArray(obj)`
   
   ## 类型转换

   ### 原始值转布尔
   只有 6 种值可以被转换成 false，
   
   不传任何参数时返回 false, 
   
   其他都会被转换成 true，
   ```js
    console.log(Boolean()) // false
    console.log(Boolean(false)) // false
    console.log(Boolean(undefined)) // false
    console.log(Boolean(null)) // false
    console.log(Boolean(+0)) // false
    console.log(Boolean(-0)) // false
    console.log(Boolean(NaN)) // false
    console.log(Boolean("")) // false
   ```