# 类型强制转换

## 1. 值类型转换

将值从一种类型转换为另一种类型通常称为类型转换（type casting）,这是显示的情况。隐式的情况称为强制类型转换（coercion）。

也可以这样区分：类型转换发生在静态类型语言的编译阶段，而强制类型转换发生在动态语言的运行时（runtime）。

然而在JavaScript中通常将它们统称为强制类型转换，我个人倾向于用“隐式强制类型转换”和“显示强制类型转换”来区分。

例如：
```js
var a = 42;
var b = a + "" // 隐式强制类型转换
var c = String(a) // 显示强制类型转换
```
对于变量b而言，强制类型转换是隐式的；由于+运算符的其中一个操作数是字符串，所以是字符串拼接操作，结果是数字42被强制类型转换为相应的字符串"42"。

而String(..)则是将a显式强制类型转换为字符串。

这里的“显式”和“隐式”以及“明显的副作用”和“隐式的副作用”都是相对而言的。

要是你明白a + ""是怎么回事，它对你来说就是“显式”的。相反，如果你不知道String(..)可以用来做字符串强制类型转换，它对你来说可能就是“隐式”的。

## 2. 抽象值操作

### 2.1 ToString

它负责处理非字符串到字符串的强制类型转换。

数组的默认toString()方法经过重新定义，将所有单元字符串化后再用“，”连接起来：

```js
var a = [1, 2, 3];
a.toString(); // 1, 2, 3
```

**JSON 字符串化**

工具JSON.stringify(..)在将JSON对象序列化为字符串时也用到了ToString().

请注意，JSON字符串化并非严格意义上的强制类型转换。

对大多数简单值来说，JSON字符串化和toString()的效果基本相同，只不过序列化的结果总是字符串：

```js
JSON.stringify(42) // "42"
JSON.stringify("42") // ""42""
JSON.stringify(null) // "null".
JSON.stringify(true) // "true".
```
所有安全的JSON值都可以使用JSON.stringify(..)。安全的JSON值是指能够呈现为有效JSON格式的值。

不安全的JSON值：undefined、function、symbol和包含循环引用的对象

例如：
```js
JSON.stringify(undefined); // undefined
JSON.stringify(function() {}) // undefined
JSON.stringify([1, undefined, function() {}, 4]) // "[1, null, null, 4]"
JSON.stringify({a: 2, b: function() {} }) // "{"a": 2}"
```
对包含循环引用的对象执行JSON.stringify(..)会出错。

如果对象中定义了toJSON方法，JSON字符串化时会首先调用该方法，然后用它的返回值来进行序列化

如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义toJSON()方法来返回一个安全的JSON值。

例如：

```js
var o = {};
var a = {
    b: 42,
    c: o,
    d: function() {}
};
// 在a中创建一个循环引用
o.e = a;
// 循环引用在这里产生错误
// JSON.stringify(a);
// 自定义的JSON序列化
a.toJSON = function() {
    return { b: this.b }
}
JSON.stringify(a); // "{"b": 42}"
```
很多人误以为toJSON返回的是JSON字符串化后的值，其实不然，除非我们确实想对字符串进行字符串化。toJSON()返回的应该是一个
适当的值，可以是任何类型，然后由JSON.stringify(..)对其进行字符串化。

我们可以向JSON.stringify(..)传递一个可选参数replacer, 它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，
哪些被排除，和toJSON很像。

如果replacer是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性被忽略。

如果replacer是一个函数，它会对对象本身调用一次，然后对对象的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回undefined,
否则返回指定的值。

```js
var a = {
    b: 42,
    c: "42",
    d: [1, 2, 3]
}
JSON.stringify(a, ["b", "c"]) // "{"b": 42, "c": "42"}"
JSON.stringify(a, function(k, v) {
    if(k !== "c") return v;
}); 
// "{"b": 42, "d":[1, 2, 3]}"
```


### 2.2 ToNumber

有时我们需要将非数字值当作数字来使用，比如数学运算。为此ES5规范在9.3节定义了抽象操作ToNumber。

其中true转换为1，false转换为0. undefined转为NaN, null转为0。

```js
var a = {
    valueOf: function() {
        return "42"
    }
}
var b = {
    toString: function() {
        return "42"
    }
}
var c = [4,2];
c.toString = function() {
    return this.join("") // "42"
}
Number(a); //42
Number(b) //42
Number(c) //42
Number("") // 0
Number([]) // 0
Number(["abc"]); // NaN
```

### 2.3 ToBoolean

1. 假值（falsy value）
我们再来看看其他值是如何被强制类型转换为布尔值的。

JavaScript中的值可以分为一下两类：
（1）可以被强制类型转为false的值
（2）其他（被强制类型转为true的值）

列举了布尔强制类型转换所有可能出现的结果。

以下这些是假值：

+ undefined
+ null
+ false
+ +0、-0、NaN
+ ""
假值的布尔强制类型转换结果为false。

从逻辑上说，假值列表以外的都应该是真值（truthy)
但JavaScript规范对此并没有明确定义，只是给出了一些示例，例如规定所有的对象都是真值，我们可以理解为假值列表以外的值都是真值。

2. 假值对象

这个标题似乎有点自相矛盾。前面讲过规范规定所有的对象都是真值，怎么还会有假值对象呢？

有人可能会以为假值对象就是包装了假值的封装对象（如""、0和false，参见第3章），实际不然。

例如：
```js
var a = new Boolean(false);
var b = new Number(0);
var c = new String("");
```

它们都是封装了假值的对象。那它们究竟是true还是false呢？答案很简单：
```js
var d = new Boolean(a && b && c);
d; // true
```
d为true，说明a、b、c都为true。

如果假值对象并非封装了假值的对象，那它究竟是什么？

值得注意的是，虽然JavaScript代码中会出现假值对象，但它实际上并不属于JavaScript语言的范畴。

浏览器在某些特定情况下，在常规JavaScript语法基础上自己创建了一些外来（exotic）值，这些就是“假值对象”。

最常见的例子是document.all，它是一个类数组对象，包含了页面上的所有元素，由DOM（而不是JavaScript引擎）提供给JavaScript程序使用。
它以前曾是一个真正意义上的对象，布尔强制类型转换结果为true，不过现在它是一个假值对象。

document.all并不是一个标准用法，早就被废止了。

有人也许会问：“既然这样的话，浏览器能否将它彻底去掉？”这个想法是好的，只不过仍然有很多JavaScript程序在使用它。

那为什么它要是假值呢？

因为我们经常通过将document.all强制类型转换为布尔值（比如在if语句中）来判断浏览器是否是老版本的IE。
IE自诞生之日起就始终遵循浏览器标准，较其他浏览器更为有力地推动了Web的发展。

if(document.all) { /＊ it's IE ＊/ }依然存在于许多程序中，也许会一直存在下去，这对IE的用户体验来说不是一件好事。

虽然我们无法彻底摆脱document.all，但为了让新版本更符合标准，IE并不打算继续支持if (document.all) { .. }。

“那我们应该怎么办？”

“也许可以修改JavaScript的类型机制，将document.all作为假值来处理！”

这并不是一个好办法。大多数JavaScript开发人员对这个坑了解得不多，不过更糟糕的还是对其置若罔闻的态度。

3. 真值（truthy value）

真值就是假值列表之外的值。

## 3. 显示强制类型转换

显式强制类型转换是那些显而易见的类型转换，很多类型转换都属于此列。

### 3.1 字符串和数字之间的显式转换

我们从最常见的字符串和数字之间的强制类型转换开始。

字符串和数字之间的转换是通过String(..)和Number(..)这两个内建函数来实现的，请注意它们前面没有new关键字，并不创建封装对象。

下面是两者之间的显式强制类型转换：

```js
var a = 42;
var b = String(a);
var c = "3.14";
var d = Number(c);
b; // "42"
c; // 3.14
```

String(..)遵循前面讲过的ToString规则，将值转换为字符串基本类型。
Number(..)遵循前面讲过的ToNumber规则，将值转换为数字基本类型。

它们和静态语言中的类型转换很像，一目了然，所以我们将它们归为显式强制类型转换。

除了String(..)和Number(..)以外，还有其他方法可以实现字符串和数字之间的显式转换:

```js
var a = 42;
var b = a.toString();

var c = "3.14";
var d = +c;

b; // "42";
d; // 3.14
```
a.toString()是显式的（“toString”意为“to a string”），不过其中涉及隐式转换。
因为toString()对42这样的基本类型值不适用，所以JavaScript引擎会自动为42创建一个封装对象（参见第3章），
然后对该对象调用toString()。这里显式转换中含有隐式转换。

上例中+c是+运算符的一元（unary）形式（即只有一个操作数）。
+运算符显式地将c转换为数字，而非数字加法运算（也不是字符串拼接，见下）。

1. 日期显式转换为数字

一元运算符+的另一个常见用途是将日期（Date）对象强制类型转换为数字

```js
var d = new Date();
+d;
```

将日期对象转换为时间戳并非只有强制类型转换这一种方法，或许使用更显式的方法会更好一些：
```js
var timestamp = new Date().getTime();
```
不过最好还是使用ES5中新加入的静态方法Date.now()：
```js
var timestamp = Date.now();
```
为老版本浏览器提供Date.now()的polyfill也很简单：
```js
if (Date.now){
    Date.now = function() {
        return +new Date();
    }
}
```
我们不建议对日期类型使用强制类型转换，应该使用Date.now()来获得当前的时间戳，使用new Date(..).getTime()来获得指定时间的时间戳。

2. 奇特的~运算符

我们在此深入探讨一下~有哪些用处？例如运算符（字位操作“或”）的空操作（no-op）0|x,它近执行ToInt32转换

字位运算符只适用于32位整数，运算符会强制操作数使用32位格式。这是通过抽象操作ToInt32来实现的。

ToInt32首先执行ToNumber强制类型转换，比如“123”会被先转成123，然后执行ToInt32。

虽然严格说来并非强制类型转换（因为返回值类型并没有发生变化），但字位运算符（如|和~）
和某些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字。

```js
0 | -0 // 0
0 | NaN // 0
0 | Infinfy // 0
0 | -Infinfy // 0
```
以上这些特殊数字无法以32位格式呈现（因为它们来自64位IEEE 754标准，参见第2章），因此ToInt32返回0。

~它首先将值强制类型转换为32位数字，然后执行字位操作“非”（对每一个字位进行反转）。

这与！很相像，不仅将值强制类型转换为布尔值<，还对其做字位反转。

字位反转是个很晦涩的主题，JavaScript开发人员一般很少需要关心到字位级别。

对~还可以有另外一种诠释，源自早期的计算机科学和离散数学：~返回2的补码。这样一来问题就清楚多了！

~x大致等同于-(x+1)。很奇怪，但相对更容易说明问题：

```js
~42 // -(42 + 1) => -43
```
在-（x + 1）中唯一能够得到0(或者严格说是-0)的x值是-1。也就是说如果x为 -1时，
~ 和一些数字值在一起会返回价值0，其他情况则返回真值。

-1是一个“哨位值”，哨位值是那些在各个类型中被赋予特殊含义的值。

在C语言中我们用-1来代表函数执行失败，用大于等于0的值来代表函数执行成功。

javaScript中的字符串的indexOf(..)方法也遵循这一惯例，该方法在字符串中搜索指定的
字符串，如果找到就返回子字符串的为（0开始），否则返回-1.

indexOf(..)不仅能够得到字符串的位置，还可以用来检查字符串中是否包含指定的子字符串，相当于一个
判断条件。例如：

```js
var a = "Hello World";

if (a.indexOf("lo") >= 0) { // true
    // 找到匹配
}

if (a.indexOf("lo") != 0) { // true
    // 找到匹配
}

if (a.indexOf("ol") < 0) { // true
    // 没找到匹配
}

if (a.indexOf("ol") === -1) { // true
    // 没找到匹配
}
```
>= 0和== -1这样的写法不是很好，称为“抽象渗漏”，意思是在代码中暴露了底层的实现细节，这里是指用-1作为失败时的返回值，这些细节应该被屏蔽掉。

现在我们终于明白~有什么用处了！~和indexOf()一起可以将结果强制类型转换（实际上仅仅是转换）为真/假值：

```js
var a = "Hello World"
~a.indexOf("lo"); // -4 <-- 真值！

if (~a.indexOf("lo")) { // true
    // 找到匹配
}
~a.indexOf("ol"); // -0 <-- 假值！
！~a.indexOf("ol"); // true
if (!~a.indexOf("lo")) { // true
    // 没找到匹配
}
}
```
如果indexOf(..)返回-1, ~将其转换为假值0，其他情况一律转换为真值。

从技术角度来说，if (~a.indexOf(..))仍然是对indexOf(..)的返回结果进行隐式强制类型转换，0转换为false，其他情况转换为true。
但我觉得~更像显式强制类型转换，前提是我对它有充分的理解。

3. 字位截除

一些开发人员使用~~来截除数字值的小数部分，以为这和Math.floor(..)的效果一样，实际上并非如此。

~~中的第一个~执行ToInt32并反转字位，然后第二个~再一次进行字位反转，即将所有字位反转回原值，
最后得到的仍然是ToInt32的结果。

对~~我们要多加注意。首先它只适用于32位数字，更重要的是它对负数的处理与Math.floor(..)不同。

``js
Math.floor(-49.6); // -50
~~-49.6; // -49
``

~~x能将值截除为32位整数，x|0也可以，而且看起来还更简洁。

对于运算符优先级的考虑，我们可能更倾向于使用~~x;

```js
~~1E20 / 10 // 166199296
1E20 | 0 / 10 // 166199296
```


### 3.2 显式解析数字字符串

解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者还是有明显的差别的。

例如：
```js
var a = "42";
var b = "42px";
Number(a); // 42
parseInt(a); // 42
Number(b) // NaN
parseInt(b) // 42
```

解析允许字符串中含有非数字字符串，解析按从左到右的顺序，如果遇到非字符串就停止。而转换不允许出现非数字字符，否则会失败返回NaN。

解析和转换之间不是替换的关系。它们虽然类似，但是各有各的用途。如果字符串右边的非数字字符不影响结果，就可以使用解析。

而转换要求字符串中的所有字符都是数字，像“42px”这样的字符串就不行。

ES5之前的parseInt(..)有一个坑导致了很多BUG。即如果没有第二个参数来指定转换的基数，parseInt(..)会根据字符串的第一个字符来自行决定基数。

如果第一个字符是x,则转为16进制数字。如果是0则转为八进制数。

**解析非字符串**

曾经有人发帖吐槽parseInt(..)的一个坑：
```js
parseInt(1/0, 19); // 18
```
很多人想当然的以为（实际大错特错）“如果第一个参数是Infinfy, 解析结果也应该是Infinfy，返回18也太无厘头了”

其实第一个错误是向parInt(..)传递非字符串，这完全自找麻烦。此时JS会将参数强制类型转换为它能够处理的字符串。

有人认为这不合理，parseInt(..)应该拒绝接受非字符串参数。但如果这样的话，它是否应该抛出一个错误？这是Java的做法。

一想到JavaScript代码中到处是抛出的错误，要在每个地方加上try..catch，我整个人都不好了。

那是不是应该返回NaN？也许吧，但是下面的情况是否应该运行失败？
```js
parseInt(new String("42"));
```
因为它的参数也是一个非字符串。如果你认为此时应该将String封装对象拆封为“42”，那么将42先转为“42”在解析回42
不也合情合理嘛？

这种半显示、半隐式的强制类型转换很多时候非常有用。例如：
```js
var a = {
    num: 21,
    toString: function() {
        return String( this.num * 2);
    }
}

parseInt(a) // 42
```
parseInt(..)先将参数强制类型转换为字符串再进行解析，这样做没有任何问题。
因为传递错误的参数而得到错误的结果，并不能归咎于函数本身。

怎么处理Infinfy(1/0的结果)最合理呢？有两个选择：“Infinity” 和“∞”，JS选择的
是“Infinity”。

JS中所有的值都有一个默认的字符串形式，这很不错，能够方便我们调试。

再回到基数，这显然是个玩笑话，在实际的JS代码中不会用到基数19。

它的有效数字字符范围是0-9和a-i（区分大小写）。

parseInt(1/0, 19)实际上是parseInt("Infinify", 19)。第一个字符是“I”，以19为基数时为18.

第二个字符是"n"不是一个有效的数字字符，解析到此位置，和“42px”中的“p”一样。

最后的结果是18，而非Infinify或者报错。所以理解其中的工作原理对于我们学习JS是非常重要的。

此外还有一些看起来奇怪但是实际上解释的通的例子：

```js
parseInt(0.000008) // 0 ("0" 来自于 "0.000008")
parseInt(0.000008) // 8 ("8" 来自于 "8e-7")
parseInt(false, 16) // 250 ("fa" 来自于 “false”)
parseInt(parseInt, 16) // 15 ("f" 来自于“function..”)
parseInt("0x10"); // 16
parseInt("103", 2); // 2
```

### 3.3 显式转换为布尔值

现在我们来看看从非布尔值强制类型转换为布尔值的情况。

与前面的String(..)和Number(..)一样，Boolean(..)（不带new）是显式的ToBoolean强制类型转换：

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;
Boolean(a) // true;
Boolean(b) // true;
Boolean(c) // true;

Boolean(d) // false
Boolean(e) // false
Boolean(f) // false
Boolean(g) // false
```
和前面讲过的+类似，一元运算符！显式地将值强制类型转换为布尔值

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;
!!a // true;
!!b // true;
!!c // true;

!!d // false
!!e // false
!!f // false
!!g // false
```

在if(..)这样的布尔值上下文中，如果没有使用Boolean(..)和！！，就会自动隐式地进行ToBoolean转换。建议使用
Boolean()和！！来进行显示转换以便让代码更加清晰易读。

显式ToBoolean的另外一个用处，是在JSON序列化过程中将值强制类型转换为true或false：

```js
var a = [
    1,
    function() {

    },
    2,
    function() {

    },
]
JSON.stringify(a); // "[1, null, 2, null]"
JSON.stringify(a, function(key, val) {
    if (typeof val === "function") {
        return !!val
    } else {
        return val;
    }
})
// "[1, true, 2, true]"
```

## 4. 隐式强制类型转换

隐式强制类型转换指的是那些隐蔽的强制类型转换，副作用也不是很明显。换句话说，你自己觉得不够明显的强制类型转换都可以算作隐式强制类型转换。

隐式强制类型转换的作用是减少冗余，让代码更简洁。

### 4.1 隐式地简化

我们先来看一个例子，它不是JavaScript代码，而是强类型语言的伪代码：

```js
SomeType x = SomeType(AnotherType(y))
```
其中变量y被转换为someType类型。问题是语言本身不允许直接将y转换为SomeType类型。于是我们多了一个中间步骤，
先将y转成AnotherType类型，然后再从AnotherType类型转成SomeType。

如果这样：

```js
SomeType x = SomeType (y)
```
省去中间的步骤，类型转换变得简洁。这些无关紧要的中间步骤可以也应该被隐藏。

也许有些情况这些中间步骤还是必要的，但是我觉得通过语言机制或定制方法来简化代码，抽象或隐藏那些细枝末节，有助于提高代码的可读性。

当然这些中间步骤仍然会发生在某处。通过隐藏这些细节，我们就可以专注于问题本身，这里是将变量y转换为SomeType类型。

### 4.2 字符串和数字之间的隐式强制类型转换

先来看一些会产生隐式强制类型转换的操作。

通过重载，+运算符即能用于数字加法，也能用于字符串拼接。JavaScript怎样来判断我们要执行的是哪个操作？例如：

```js
var a = "42"
var b = "0";

var c = 42
var d = 0;

a + b = "420";
c + d = 42;
```
这里为什么会得到"420"和42两个不同的结果呢？通常的理解是，因为某一个或者两个操作数都是字符串，所以+执行的是字符串拼接操作。
这样解释只对了一半，实际情况要复杂得多。

例如：
```js
var a = [1,2];
var b = [3,4];
a + b // "1,23,4";
```
a和b都不是字符串，但是它们都被强制类型转换为字符串后拼接。原因何在？

如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+将进行拼接操作。
如果其中一个操作数是对象（包括数组）则首先对其调用ToPrimitive抽象操作（规范9.1节）
该抽象操作再调用[[DefaultValue]]（规范8.12.8节），以数字作为上下文。

你或许注意到这与ToNumber抽象操作处理对象的方式一样，因为数组的valueOf()操作无法得到简单基本类型值。
于是它转而调用toString()。因此上例中的两个数组变成了"1,2"和"3,4"。+将它们拼接后返回"1,23,4"。

简单来说就是，`如果+的其中一个操作数是字符串（或者通过以上步骤可以得到字符串），则执行字符串拼接`；否则执行数字加法。

有一个坑常常被提到，即[] + {}和{} + []，它们返回不同的结果，分别是"[object Object]"和0

对隐式强制类型转换来说，这意味着什么？

我们可以将数字或空字符串“”相+来将其转为字符串：

```js
var a =  42;
var b = a + "";
b // "42"
```

a + ""(隐式)和前面的String(a)(显示) 之间有一个细微的差别需要注意。根据ToPrimitive抽象操作规则，
a + ""会对a调用valueOf()方法，然后通过ToString抽象操作将返回值转换为字符串。而String(a)则是直接调用ToString()。

它们最后返回的都是字符串，但如果a是对象而非数字结果可能不一样！

例如：
```js
var a = {
    valueOf: function() { return 42 },
    toString: function() { return 4 }
}
a + ""; // "42"
String(a); // "4"
```
再来看看从字符串强制类型转换为数字的情况。
```js
var a = "3.14";
var b = a -0;
b  // 3.14
```
-是数字减法运算符，因此a -0 将a强制类型转换为数字。也可以使用a * 1 和 a / 1,因为这两个运算符也只适用于数字，
只不过这样的用法不常见。

对象的-操作与+类似：
```js
var a = [3];
var b = [1];
a - b; // 2
```
为了执行减法运算，a和b 都需要被转为数字，它们首先被转为字符串（通过toString()）,然后再转为数字。

b = String(a)(显示) 和 b = a + ""(隐式)各有优点，b = a + ""更常见一些。虽然饱受诟病，但隐式强制类型转换仍然有它的用处。

### 4.3 布尔值到数字的隐式强制类型转换

在将某些复杂的布尔逻辑转换为数字加法的时候，隐式强制类型转换能派上大用场。当然这种情况并不多见，属于特殊情况特殊处理。

例如：

```js
function onlyOne(a, b, c) {
    return !!((a && !b && !c)
    || (!a && b && !c) || (!a && !b && c))
}
var a = true;
var b = false;

onlyOne(a, b, b) // true
onlyOne(b, a, b) // true
onlyOne(a, b, a) // false
```
如果其中有且仅有一个参数为true，则onlyOne(..)返回true。其在条件判断中使用了隐式强制类型转换，其他地方则是显式的，包括最后的返回值。

但如果有多个参数时（4个、5个，甚至20个），用上面的代码就很难处理了。这时就可以使用从布尔值到数字（0或1）的强制类型转换.

```js
function onlyOne() {
    var sum = 0;
    for(var i = 0; i < arguments.length; i++){
        if(arguments[i]) {
            sum += arguments[i]
        }
    }
    return sum == 1;
}
var a = true;
var b = false;

onlyOne(b, a); // true
onlyOne(b, a, b, b, b, b) //true
```
在onlyOne(..)中除了使用for循环，还可以使用ES5规范中的reduce(..)函数。

通过sum += arguments[i]中的隐式强制类型转换，将真值（true/truthy）转换为1并进行累加。

如果有且仅有一个参数为true，则结果为1；

否则不等于1, sum== 1条件不成立。同样的功能也可以通过显式强制类型转换来实现：

```js
function onlyOne() {
    var sum = 0;
    for(var i = 0; i < arguments.length; i++){
        if(arguments[i]) {
            sum += Number(!!arguments[i])
        }
    }
    return sum === 1;
}
```

### 4.4 隐式强制类型转换为布尔值

现在我们来看看到布尔值的隐式强制类型转换，它最为常见也最容易搞错。

相对布尔值，数字和字符串操作中的隐式强制类型转换还算比较明显。

下面的情况会发生布尔值隐式强制类型转换。

(1) if (..)语句中的条件判断表达式。

(2) for ( .. ; .. ; .. )语句中的条件判断表达式（第二个）。

(3) while (..)和do..while(..)循环中的条件判断表达式。

(4) ? ：中的条件判断表达式。

(5) 逻辑运算符||（逻辑或）和&&（逻辑与）左边的操作数（作为条件判断表达式）。

以上情况中，非布尔值会被隐式强制类型转换为布尔值，遵循前面介绍过的ToBoolean抽象操作规则。

例如：
```js
var a = 42;
var b = "abc";
var c;
var d = null;

if (a) {
    console.log("yep"); // "yep"
}

while(c) {
    console.log("nope, never runs");
}

c = d ? a : b;
c ; // "abc"

if ((a && d) || c) {
    console.log("yep"); // "yep"
}

```
上例中的非布尔值会被隐式强制类型转换为布尔值以便执行条件判断。

### 4.5 ||和&&

逻辑运算符||（或）和&&（与）应该并不陌生，也许正因为如此有人觉得它们在JavaScript中的表现也和在其他语言中一样。

这里面有一些非常重要但却不太为人所知的细微差别。

我其实不太赞同将它们称为“逻辑运算符”，因为这不太准确。

称它们为“选择器运算符”（selector operators）或者“操作数选择器运算符”（operandselector operators）更恰当些。

为什么？因为和其他语言不同，在JavaScript中它们返回的并不是布尔值。

它们的返回值是两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值。

引述ES5规范11.11节：

&&和||运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。

例如：

```js
var a = 42;
var b = "abc";
var c;

a || b; // 42
a && b; // "abc"

c || b; // "abc"
c && b; // null 
```
在C和PHP中，上例的结果是true或false，在JavaScript（以及Python和Ruby）中却是某个操作数的值。

**|| 和 && 首先会对第一个操作数（a或者c）执行条件判断，如果其不是布尔值（如上例）就先进行ToBoolean强制类型转换，然后再执行判断。**

**对于 || 来说，如果条件判断结果为true就返回第一个操作数（a或者c）,如果判断结果为false就返回第二个操作数（b）**

**&&则相反，如果条件判断结果为true就返回第二个操作数（b）的值，如果为false就返回第一个操作数（a和c）的值。**

||和&&返回它们其中一个操作数的值，而非条件判断的结果（其中可能涉及强制类型转换）。

c && b中c为null，是一个假值，因此&&表达式的结果是null（即c的值），而非条件判断的结果false。

换一个角度来理解：
```js
a || b 
// 大致相等于

a ? a : b;

a && b;
// 大致相等于
a ? b : a; 
```

下面十分常见的用法，也许你已经用过但并未完全理解

```js
function foo(a, b) {
    a = a || "hello"
    b = b || "world"
    console.log(a + "" + b)
}
foo(); // "hello world"
foo("yeah", "yeah!") // "yeah yeah!"
```
a = a || "hello" (又成为C#的空值合并运算符的JS版本)检查变量a,如果还未赋值（或者假值），就赋予他一个默认值（hello）。

这里需要注意!

```js
foo("That's is it!", "") // "That's is it world"
```

第二个参数""是一个假值（falsy value），因此b = b || "world"条件不成立，返回默认值"world"。

这种用法很常见，但是其中不能有假值除非加上更明确的条件判断，或者转而使用？ :三元表达式。

通过这种方式来设置默认值很方便，甚至那些公开诟病JavaScript强制类型转换的人也经常使用。

再来看看&&。有一种用法对开发人员不常见，然而JavaScript代码压缩工具常用。

就是如果第一个操作数为真值，则&&运算符“选择”第二个操作数作为返回值，这也叫作“守护运算符”（guard operator），
即前面的表达式为后面的表达式“把关”：
```js
function foo() {
    console.log(a)
}
var a = 42;
a && foo(); // 42
```
foo()只有在条件判断a通过时才会被调用。如果条件判断未通过，a && foo()就会悄然终止（也叫作“短路”, short circuiting）, foo()不会被调用。这样的用法对开发人员不太常见，开发人员通常使用if (a) { foo(); }。但JavaScript代码压缩工具用的是a && foo()，因为更简洁。以后再碰到这样的代码你就知道是怎么回事了。||和&&各自有它们的用武之地，前提是我们理解并且愿意在代码中运用隐式强制类型转换。[插图]a = b || "something"和a && b()用到了“短路”机制。

你大概会有疑问：既然返回的不是true和false，为什么a && (b || c)这样的表达式在if和for中没出过问题？

这或许并不是代码的问题，问题在于你可能不知道这些条件判断表达式最后还会执行布尔值的隐式强制类型转换。

例如：
```js
var a = 42;
var b = null;
var c = "foo";

if (a && (b || c)) {
    console.log("yep");
}
```
这里a && (b || c)的结果实际上是"foo"而非true，然后再由if将foo强制类型转换为布尔值，所以最后结果为true。现在明白了吧，这里发生了隐式强制类型转换。如果要避免隐式强制类型转换就得这样：
```js
if (!!a && (!!b || !! c)) {
    console.log("yep")
}
```
## 4.6 符号的强制类型转换

ES6中引入了符号类型，它的强制类型转换有一个坑.
ES6允许从符号到字符串的显示强制类型转换，然而隐式强制类型转换会产生错误。

```js
var s1 = Symbol("cool");
String(s1); // "Symbol(cool)";
var s2 = Symbol("not cool");
s2 + ""; // TypeError;
```
符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是true）。

由于规则缺乏一致性，我们要对ES6中符号的强制类型转换多加小心。

## 5 宽松相等和严格相等

松相等（loose equals）==和严格相等（strict equals）===都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。

正确的解释是：“==允许在相等比较中进行强制类型转换，而===不允许。”

### 1. 其他类型和布尔类型之间的相等比较

==最容易出错的一个地方是true和false与其他类型之间的相等比较。

```js
var a = "42";
var b = true;
a == b; // false
```

我们都知道"42"是一个真值（见本章前面部分），为什么==的结果不是true呢？
原因既简单又复杂，让人很容易掉坑里，很多JavaScript开发人员对这个地方并未引起足够的重视。

规范11.9.3.6-7是这样说的：

(1) 如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果；

(2) 如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果。

仔细分析，首先
```js
var x = true;
var y = "42";
x == y; // false
```
Type(x)是布尔值，所以ToNumber(x) 将true 强制转化为 1，变成 1 == "42",

二者的类型仍然不同，"42"根据规则被强制类型转换为42，最后变成1 == 42，结果为false。

反过来也是一样的

```js
var x = "42"
var y = false;
x == y // false
```

Type(y) 是布尔值，所以ToNumber(y)将false强制类型转换为0，然后"42" == 0再变成42 == 0，结果为false。

也就是说，字符串"42"既不等于true，也不等于false。一个值怎么可以既非真值也非假值，这也太奇怪了吧？

这个问题本身就是错误的，我们被自己的大脑欺骗了。

"42"是一个真值没错，但"42" == true中并没有发生布尔值的比较和强制类型转换。

这里不是"42"转换为布尔值（true），而是true转换为1, "42"转换为42。

这里并不涉及ToBoolean，所以"42"是真值还是假值与==本身没有关系！

重点是我们要搞清楚==对不同的类型组合怎样处理。==两边的布尔值会被强制类型转换为数字。很奇怪吧？

我个人建议无论什么情况下都不要使用== true和== false。

请注意，这里说的只是==, === true和=== false不允许强制类型转换，所以并不涉及ToNumber。

避免了== true和== false（也叫作布尔值的宽松相等）之后我们就不用担心这些坑了。

3. null 和 undefined之间的相比较

null 和 undefined 之间的 == 也涉及隐式类型转换。ES5规范11.9.3.2-3规定：

（1）如果x为null,y为undefined,则结果为true。
（2）如果x为undefined,y为null,则结果也为true。

在 == 中null和undefined相等（它们也与其自身相等），除此之外其他值都不存在这种情况。

这也就是，在 == 中 null和undefined是一回事，可以互相进行隐式强制类型转换。

```js
 var a = null;
 var b;

 a == b // true
 a == null // true
 b == null // true

 a == false // false
 b == false // false
 a == "" // false
 b == "" // false
 a == 0 // falese
 b == 0 // false
 ```

 null 和 undefined之间的强制类型转换是安全可靠的，上例中除null和undefined以外的其他值均无法
 得到假阳（false positive）结果。个人认为通过这种方式将null和undefined作为等假肢来处理比较好。

 4. 对象和非对象之间的相比较

 关于对象（对象、函数、数组）和标量类型（字符串、数字、布尔值）之间的相比较，

 （1）如果Type(x)是字符串活数字，type(y)是对象，则返回x == ToPrimitive(y)的结果

  (2) 如果Type(x)是对象，Type(y)是字符串或数字，则返回ToPrimitive(x) == y的结果。

  例如：
  ```js
    var a = 42;
    var b = [ 42 ];

    a == b; // true
  ```

  [42]首先掉用ToPrimitive抽象操作，返回“41”，变成“42” == 42，然后又变成 42 == 42, 最后二者相等。

  在第3章中，我们介绍过“拆封”，即“打开”封装对象（如 new String("abc")),返回其中的基本数据类型值
  （“abc”）。==中的Toprimitive强制类型转换也会发生这样的情况：

  ```js
  var a = "abc";
  var b = Object(a); // 和new String(a) 一样
  a === b; // false
  a == b; true
  ```

  a == b 结果为true, 因为b通过ToPrimitive进行强制类型转换（也称”拆封，英文为unboxed）,并返回标量
  基本类型值"abc",与a相等。

  但有一些值不这样，原因是==算法中其他优先级更高的规则。例如：

  ```js
  var a = null;
  var b = Object(a);
  a == b // false

  var c = undefined;
  var d = Object(c) 

  c == d // false

  var e = NaN;
  var f = Object(e)
  e == f; // false
  ```

  因为没有对于的封装对象，所以null和undefined不能够被封装，Object(null)和Object均返回一个常规对象。

  NaN能够被封装为数字封装对象，但拆封之后NaN == NaN返回false,因为NaN不等于NaN.

  5. 比较少见的情况

  现在来看一下那些需要特别注意和避免的比较少见的情况。

  首先来看看更改内置原生原型会导致哪些奇怪的结果。

  (1). 返回其他数字

  ```js
  Number.prototype.valueOf = function() {
      return 3;
  }
  new Number(2) == 3 // true
  ```

  2 == 3 不会有这种问题，因为2和3都是数字的基本类型值，不会调研Number.prototy.valueOf()方法。
  而Number（2）设计ToPrimitive强制类型转换，因此调用valueOf()。

  真是让人头大。这也是强制类型转换和 == 被诟病的原因。但问题并非出自JS，而是我们自己。不要
  有这样的想法，觉得“编程语言应该阻止我们犯错”。

  还有更奇怪的情况：

  ```js
  if (a == 2 && a == 3) {
    
  }
  ```

  也许觉得这不可能，因为a不会同时等于2和3。但“同时”一词并不准确，因为a ==2在a == 3之前执行。

  如果让a.valueOf()每次调用都产生副作用，比如第一次返回2，第二次返回3，就会出现这样的情况。
  
  这实现起来很简单：

  (2). 假值得相等比较

  == 中得隐式强制类型转换最为人诟病得地方是假值得相等比较。

  下面分别列出了常规和非常规得情况：

  ```js
  "0" == null // false
  "0" == undefined // false
  "0" == false // true 

  "0" == NaN; // false
  "0" == 0 // true
  "0" == "" // false

  false == null // false
  false == undefined // false
  false == NaN // false

  false == 0 // true
  false == "" // true
  false == [] // true
  
  false == {} // false

  "" == null // false
  "" == undefined // false
  "" == NaN // false

  "" == 0; // true

  "" == []; //true
  "" == {}; // false

  0 == null // false
  0 == undefined // false
  0 == NaN // false

  0 == []; // true

  0 == {} // false
  ```

  以上24种情况中有17种比较好理解。比如我们都知道""和NaN不相等，"0"和0相等。

  (3)．极端情况这还不算完，还有更极端的例子：

  ```js
  [] == ![] // true
  ```

  事情变得越来越疯狂了。看起来这似乎是真值和假值的相等比较，结果不应该是true，
  
  因为一个值不可能同时既是真值也是假值！

  事实并非如此。让我们看看！运算符都做了些什么?

  根据ToBoolean规则，它会进行布尔值的显式强制类型转换（同时反转奇偶校验位）

  所以[] == ![]变成了 [] == false。 前面我们讲过 false == [], 最后的结果就顺理成章了

  再看看其他的情况：

  ```js
  2 == [2] // true
  "" == [null] // true
  ```

  介绍ToNumber时我们讲过， == 右边的值[2]和 [null]会进行ToPrimitive强制类型转换，以便能够
  和左边的基本来信（2和“”）进行比较。因为数组的ValueOf()返回数字本身，所以强制类型转换过程
  中数字会进行字符串化。

  第一行中的[2]会被转换为"2",然后通过ToNumber转换为2。第二行中的[null]会直接转换为""。

  所以最后的结果就是 2 == 2 和 "" == ""。

  如果还是觉得头大，那么你的困惑可能并非来自强类型转换，而是ToPrimitive将数字转为字符串这一过程。
  也许你认为[2].toString()返回的不是“2”，[null].toString()返回的也不是""。

  但是如果不这样处理的话又能怎样呢？我是在想不出其他更好的办法。或许应该将[2]转换为"[2]",
  但这样的话在别的地方又显得很奇怪。

  有人也会会觉得既然String(null)返回"null",所以String([null])也应该返回"null"。确实有道理，
  但这就是问题所在。

  隐式强制类型转换本身不是问题的根源，因为[null]在显示强制类型转换中也是转为""。问题在于将数组转为
  字符串是否合理，具体该如何处理。所以实际上这是String([..])规则的问题。又或者根本就不应该将数组转换
  为字符串？但这样一来又会导致很多其他问题。

  还有一个坑常常会提到：
  ```js
    0 == "\n"; // true
  ```

  前面介绍过，“”、“\n”(或者“ ”等其他空格组合)等空字符串被ToNumbr强制类型转换为0。这样处理总没有问题了吧？
  不然你要怎么办?

  或许可以将字符串或空格转为NaN,这样“” == NaN就为false了，然而这并没有根本上解决问题。

  0 == “\n”导致程序出错的几率少之又少，很容易避免。

  类型转换总会出现一些特殊情况，并非只有强制类型转换，任何编程语言都是如此。
  问题出在我们的臆断（有时或许碰巧猜对了），但这并不能成为诟病强制类型转换
  机制的理由。

  上述7种情况基本涵盖了所有我们可能遇到的坑（除修改valueOf()和toStrign()的情况以外）。

  与前面24种情况列表相对应的是下面这个列表：

  ```js
   42 == "43" // false
   "foo" == 42 // false
   "true" == true // false

   42 == "42" // true
   "foo" == ["foo"] // true
  ```

  这些是非假值的常规情况（实际上还可以加上无穷大数字的相等比较），其中涉及的强制类型转换是安全的，也比较好理解。

  (4)．完整性检查

  我们深入介绍了隐式强制类型转换中的一些特殊情况。也难怪大多数开发人员都觉得这太晦涩，唯恐避之不及。

  现在回过头来做一下完整性检查（sanity check）。

  前面列举了相等比较中的强制类型转换的7个坑，不过另外还有至少17种情况是绝对安全和容易理解的。

  因为7棵歪脖树而放弃整片森林似乎有点因噎废食了，所以明智的做法是扬其长避其短。

  再来看看那些“短”的地方：

  ```js
  false == "0" // true
  false == 0 // true
  false == "" // true
  false == [] // true

  "" == 0 // true
  "" == [] // true

  0 == []
  ```

  其中有4种情况涉及== false，之前我们说过应该避免，应该不难掌握。

  现在剩下3种：

  ```js
  "" == 0 // true
  "" == [] // true

  0 == []
  ```

 正常情况下我们应该不会这样来写代码。我们应该不太可能会用== []来做条件判断，而是用== ""或者== 0，如：

 ```js
    function doSomething(a) {
        if (a == "") {
            ...
        }
    }
 ```
 如果不小心碰到doSomething(0)和doSomething([])这样的情况，结果会让你大吃一惊。又如：
```js
 function doSomething(a, b){
     if(a == b) {
         ..
     }
 }
```
doSomething("",0)和doSomething([], "")也会如此。这些特殊情况会导致各种问题，我们要多加小心，好在它们并不十分常见。

(5). 安全运用隐式强制类型转换

我们要对 == 两边的值认真推敲，以下两个原则可以让我们有效的避免错误：

+ 如果两边的值中有true或者false，千万不要使用==。
+ 如果两边的值中有[]、""或者0，尽量不要使用==。

这时最好用===来避免不经意的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。

这种情况下强制类型转换越显式越好，能省去很多麻烦。

**所以==和===选择哪一个取决于是否允许在相等比较中发生强制类型转换。**

强制类型转换在很多地方非常有用，能够让相等比较更简洁（比如null和undefined）。

隐式强制类型转换在部分情况下确实很危险，这时为了安全起见就要使用===。

### 6. 抽象关系比较

a < b 中涉及的隐式强制转换不太引起人注意，不过还是有必要深入了解一下。

ES5规范11.8.5节定义了“抽象关系比较”（abstract relational comparison），
分为两个部分：较双方都是字符串（后半部分）和其他情况（前半部分）。

比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则将双方强制类型转换为数字来进行比较。

```js
var a = [ 42 ];
var b = [ "43" ];

a < b; // true
b < a // false
```

如果比较双方都是字符串，则按字母顺序来进行比较：

```js
var a = ["42"];
var b = ["043"];

a < b; // false
```
a和b并没有被转换为数字，因为ToPrimitive返回的是字符串，所以这里比较的是"42"和"043"两个字符串，它们分别以"4"和"0"开头。

因为"0"在字母顺序上小于"4"，所以最后结果为false。

下面的例子就有些奇怪了：

```js
var a = { b: 42 };
var b = { b: 43 }

a < b; // false
a == b // false
a > b; // false

a <= b // true
a >= b // true
```

为什么a == b的结果不是true？它们的字符串值相同（同为"[object Object]"），按道理应该相等才对？实际上不是这样，你可以回忆一下前面讲过的对象的相等比较。

但是如果a < b 或者a == b结果为false,为什么a <= b 和a >=b的结果是true呢？

因为根据规范a <= b被处理为b < a，然后将结果反转。 因为b < a的结果是false，所以a <= b的结果是true。

这可能与我们设想的大相径庭，即<=应该是“小于或者等于”。实际上JavaScript中<=是“不大于”的意思（即！(a > b)，处理为！(b < a)）。同理，a >= b处理为b <= a。
