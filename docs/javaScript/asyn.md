# 异步

## 1. 分块的程序

可以把js程序写在单个.js文件中，但是这个程序几乎一定是由多个块构成的。这些块中只有一个是现在执行的，其余的则会在将来执行。
最常见的块单位是函数。

大多数js新手程序员都会遇到的问题：程序将来执行的部分并不一定在现在运行的部分执行完后就立即执行。换句话说，现在无法完成的部分将会异步完成，
因此并不会出现人们本能认为地认为会出现的或希望出现的阻塞行为。

考虑：

```js
a.ajax() // ajax是某个库中提供的某个Ajax函数
var data = ajax("http://some.url");
console.log(data);
// data通常不会包含Ajax的结果。
```

你可能已经了解，标准Ajax请求不是同步完成的，这意味着ajax(..)函数还没有返回任何值可以赋给变量data。

如果ajax(..)能够阻塞到响应返回，那么data = .．赋值就会正确工作。

但我们并不是这么使用Ajax的。现在我们发出一个异步Ajax请求，然后在将来才能得到返回的结果。

从现在到将来的“等待”，最简单的方法（但绝对不是唯一的，甚至也不是最好的！）是使用一个通常称为回调函数的函数：

```js
a.ajax() // ajax是某个库中提供的某个Ajax函数
var data = ajax("http://some.url", function myCallbackFunction(data) {
    console.log(data);
});
```

但为了避免回调函数引起的混乱并不足以成为使用阻塞式同步Ajax的理由。

举例来说，考虑一下下面这段代码：

```js
function now() {
    return 21
}

function later() {
    answer = answer * 2;
    console.log("Meaning of life:" answer)
}

var answer = now();
 
setTimeout(later, 1000); // Meaning of life: 42
```

这个程序有两个块：现在执行的部分，以及将来执行的部分。这两块的内容很明显，但这里我们还是要明确指出来。

现在： 

```js
function now() {
    return 21;
}

function later(..) {

}

var answer = now();

setTimout(later, 1000);
```
将来：
```js
answer = answer * 2;
console.log("Meaning of life:" answer)
```
现在这一块在程序运行之后就会立即执行。但是，setTimeout(..)还设置了一个事件（定时）在将来执行，所以函数later()的内容会在之后的某个时间（从现在起1000毫秒之后）执行。

任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制。

**异步控制台**

并没有什么规范或一组需求指定console.*方法族如何工作————它们并不是JS的正式的一部分，而是宿主环境添加到js中的。

因此不同的浏览器和JS环境可以按照自己的意愿来实现。

尤其要提出的是，在某些情况下，某些浏览器的console.log(..)并不会把传入的内容立即输出。出现这种情况的主要原因是，
在许多程序（不只是JS）中，I/O是非常低速的阻塞部分。所以（从页面/UI的角度来说）浏览器在后台异步处理控制台I/O能
提高性能，这时用户甚至可能根本意识不到其发生。

下面这种情景不是很常见，但也可能发生，从中（不是从代码本身而是从外部）可以观察到这种情况：

```js
var a = {
    index: 1
}

console.log(a) // ??

a.index++
```
我们通常认为恰好在执行到console.log(..)语句的时候会看到a对象的快照，打印除出类似于{index:1}的内容，然后再下一条语句a.index++
执行时将其修改，这句的执行会严格在a的输出之后。

多数情况，前述的代码在开发者工具的控制台输出的对象表示与期望是一致的。但是，这段代码运行的时候，浏览器可能会认为需要控制台I/O
延迟到后台，在这种情况下，等到浏览器控制台输出对象内容时，a.index++可能以及执行，因此会显示{index:2}

到底什么时候控制台I/O会延迟，甚至是否能被观察到，这都不一定。如果在调试的过程中遇到对象在console.log(..)语句后被修改，可你却看到了
意料之外的结果，要意识到这可能是这种I/O的异步化造成的。

如果遇到这种少见的情况，最好的选择是在JavaScript调试器中使用断点，而不要依赖控制台输出。
次优的方案是把对象序列化到一个字符串中，以强制执行一次“快照”，比如通过JSON.stringify(..)。


## 2. 事件循环

现在我们来澄清一件事情（可能令人震撼）：尽管你能编写好异步JS代码（就像我们前面所看到的代码），但直到ES6，js才真正内建有直接的异步概念。

什么？！这种说法似乎很疯狂，对不对？但事实就是这样。JavaScript引擎本身所做的只不过是在需要的时候，在给定的任意时刻执行程序中的单个代码块。

“需要”，谁的需要？这正是关键所在！

JS引擎并不是独立运行的，它运行在宿主环境中，对多数开发者来说通常就是Web浏览器。经过最近几年（不仅于此）的发展，js已经超出了浏览器的范围，
比如通过像Node.js这样的工具进入服务器领域。实际上，JavaScript现如今已经嵌入到了从机器人到电灯泡等各种各样的设备中。

但是，所有这些环境都有一个共同“点”（threa, 也指线程。不论真假与否，这都不算一个很精妙的异步笑话），即它们都提供一种机制**来处理程序中多个块的执行，且执行每块时调用js引擎**，这种机制被称为事件循环。

换句话说，**js引擎本身没有时间的概念，只是一个按需执行JS任意代码片段的环境。“事件”调度总是由包含它的环境进行。**

所以，举例来说，如果你的JS程序发出一个AJax请求，从服务器获取一些数据，那你就在一个函数（回调函数）中设置好响应代码，然后JS引擎会通知宿主环境；
“嘿，现在我要暂停执行，你一旦完成网络请求，拿到了数据，就请调用这个函数”。

然后浏览器就会设置侦听来自网络的响应，拿到要给你的数据后，就会把回调函数插入到事件循环，以此实现对这个回调的调度执行。

那么，什么是事件循环？

先通过一段伪代码了解一下这个概念：
```js
// eventLoop是一个用作队列的数组
// (先进，先出)
var eventLoop = [];
var event;

// "永远" 执行
while(true) {
    // 一次tick
    if (eventLoop.length > 0) {
        // 拿到队列的下一个事件
        event = eventLoop.shift();

        // 现在，执行下一个事件

        try {
            event();
        } catch (err) {
            console.log(err)
        }
    }
}
```
有一个用while循环实现的持续运行的循环，循环的每一轮成为一个tick。对于每个tick而言，如果队列中有等待事件，那么就会从队列中摘下一个事件并执行。

这些事件就是你的回调函数。

一定要清楚，setTimeut(..)并没有把你的回调函数挂到事件循环队列中。它所做的的是一个设定一个定时器。当定时器到时后，环境会把你的回调函数挂到事件循环中，
这样，在某个未来时刻的tick会摘下并执行这个回调。

如果这时候事件循环中已经有了20个项目了会怎么样呢？你的回调就会等待。它排在其他项目后面————通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么
**setTimeout(..)定时器的精度可能不高。大体说来，只能确保你的回调函数不会在指定的时间间隔之前运行，但可能在那个时刻运行，也可能在那之后运行，要根据队列的状态而定。**

所以换句话说，**程序通常分成了很多小块，在事件循环队列中一个接一个地执行**。严格来说，和你的程序不直接相关的其他事件也可能插入到队列中。

## 3. 并行线程

术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不一样。记住，**异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。**

并行计算最常见的工具就是**进程和线程**。**进程和线程独立进行，并可能同时进行：在不同的处理器，甚至不同的计算机上，但是多个线程能够共享单个进程的内存。**

与之相对的是，事件循环把自身的工作分成一个个任务顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。

并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。

举例来说：

```js
function later () {
    answer = answer * 2;
    console.log("m of life", answer);
}
```
尽管later的所有内容被看作单独的一个事件循环队列表项，但**如果考虑到这段代码是运行在一个线程中。实际上可能会有很多不同的底层运算。**
比如，answer = answer * 2 需要先加载answer的当前值，然后把2放到某处并执行乘法，取得结果后保存会answer。

在单线程环境中，线程队列中的这些项目的底层运算确实是无所谓的，因为线程本身不会被中断。但是如果是在并行系统中，同一个程序中可能有两个不同的
线程在运转，这时很可能会得到不确定的结果。

考虑： 

```js
var a = 20;
function foo() {
    a = a + 1;
}
function bar() {
    a = a * 1;
}
ajax("http1", foo);
ajax("http2", bar);
```
根据JS的单线程运行特性，如果在foo运行在bar之前，a的结果是42，而如果bar()运行在foo()之前的话，a的结果就是41。

如果共享同一数据的js事件并行的话，那么问题就变得更加微妙了。

考虑foo()和bar()中代码运行的线程分别执行的是以下两段伪代码，然后思考一下如果它们恰好同时运行的话会出现什么情况。

线程1（x和y是临时内存地址）：

```js
foo();
a. 把a的值加载到X
b. 把1保存到Y
c. 执行X加Y，结果保存在X
d. 把X的值保存在a
```
线程2（X和Y是临时内存地址）：
```js
foo();
a. 把a的值加载到X
b. 把2保存到Y
c. 执行X乘Y，结果保存在X
d. 把X的值保存在a
```
现在，假设两个线程并行执行。你可能已经发现了这个程序的问题。它们在临时步骤中使用了共享的内存地址X和Y。

如果按照以下步骤执行，结果会是什么呢？

```js
1a(把a的值加载到X) ==> 20
2a(把a的值加载到X) ==> 20
1b(把1保存在Y) ==> 1
2b(把2保存在Y) ==> 2
1c(执行X加Y，结果保存在X) ==> 22
1d(把X的值保存在a) ==> 22
2c(执行X乘Y，结果保存在X) ==> 44
2d(把X的值保存在a) ==> 44
```
a的结果将会是44。但如果按照下面顺序呢？

```js
1a(把a的值加载到X) ==> 20
2a(把a的值加载到X) ==> 20
2b(把2保存在Y) ==> 2
1b(把1保存在Y) ==> 1
2c(执行X乘Y，结果保存在X) ==> 20
1c(执行X加Y，结果保存在X) ==> 21
1d(把X的值保存在a) ==> 21
2d(把X的值保存在a) ==> 41
```
a的结果将是21。

所以，多线程编程是非常复杂的。因为如果不通过特殊的步骤来防止这种中断和交错运行的话，可能会得到出乎意料的、不确定的行为，通常这很让人头疼。

JavaScript从不跨线程共享数据，这意味着不需要考虑这一层次的不确定性。

但是这并不意味着JavaScript总是确定性的。回忆一下前面提到的，foo()和bar()的相对顺序改变可能会导致不同结果（41或42）。

**完成运行**

由于JavaScript的单线程特性，foo()（以及bar()）中的代码具有原子性。

也就是说，一旦foo()开始运行，它的所有代码都会在bar()中的任意代码运行之前完成，或者相反。这称为完整运行（run-to-completion）特性。

实际上，如果foo()和bar()中的代码更长，完整运行的语义就会更加清晰，比如：

```js
var a = 1
var b = 2;

function foo () {
    a++;
    b = b * a;
    a = b + 3;
}

function bar() {
    b--;
    a = 8 + b;
    b = a * 2;
}
ajax("http1", foo);
ajax("http2", bar);

```
由于foo()不会被bar()中断，bar()也不会被foo()中断，所以这个程序只有两个可能的输出，取决于这两个函数哪个先运行——如果存在多线程，且foo()和bar()中的语句可以交替运行的话，可能输出的数目将会增加不少！

块1是同步的（现在运行），而块2和块3是异步的（将来运行），也就是说，它们的运行在时间上是分隔的。

块1
```js
var a = 1;
var b = 2;
```
块2(foo())
```js
a++;
b = b * a;
a = b + 3;
```
块3（ bar()）
```js
b--;
a = 8 + b;
b = a * 2;
```
块2和块3哪个先运行都有可能，所以如下所示，这个程序有两个可能输出。

输出一
```js
var a = 1;
var b  =2;

foo()//
a++;
a++;
b = b * a;
a = b + 3;
bar()
b--;
a = 8 + b;
b = a * 2;
a // 11
b //22
```
输出二
```js
bar()
var a = 1;
var b  =2;
b--;
a = 8 + b;
b = a * 2;
foo()//
a++;
a++;
b = b * a;
a = b + 3;

a // 183
b //180
```
同一段代码有两个可能输出意味着还是存在不确定性！
但是，这种不确定性是在函数（事件）顺序级别上，而不是多线程情况下的语句顺序级别（或者说，表达式运算顺序级别）。
换句话说，这一确定性要高于多线程情况。

在JavaScript的特性中，这种**函数顺序的不确定性就是通常所说的竞态条件（racecondition）**, foo()和bar()相互竞争，看谁先运行。

具体来说，因为无法可靠预测a和b的最终结果，所以才是竞态条件。

## 4 并发

现在让我们来设想一个展示状态更新列表（比如社交网络新闻种子）的网站，其随着用户向下滚动列表而逐渐加载更多内容。

要正确地实现这一特性，需要（至少）两个独立的“进程”同时运行（也就是说，是在同一段时间内，并不需要在同一时刻）。

第一个“进程”在用户向下滚动页面出发onScroll事件时响应这些事件（发起Ajax请求要求新的内容）。

第二个“进程”接收Ajax响应（把内容展示到页面）。

显然，如果用户滚动页面足够快的话，在等待第一个响应返回并处理的时候可能会看到两个或多个onScroll事件被触发，因此将
得到彼此交替的onscroll事件和Ajax事件。

两个或多个“进程”同时执行就出现了并发，不管组成它们的单个运算是否并行执行（在独立的处理器或者处理器核心上同时运行）。
可以把并发看作“进程”级（或者任务级）的并行，与运算级的并行（不同处理器的线程）相对。

在给定的时间窗口内，我们看看把各个独立的“进程”表示为一系列事件/运算是什么样的：

“进程”1（onscoll事件）：
```js
// onscroll，请求1
// onscroll，请求2
// onscroll，请求3
// onscroll，请求4
// onscroll，请求5
// onscroll，请求6
// onscroll，请求7
```
“进程”2（Ajax响应事件）：
```js
// 响应1
// 响应2
// 响应3
// 响应4
// 响应5
// 响应6
// 响应7
```
很可能某个onscoll事件和某个Ajax事件恰好同时在处理。举例来说，假设这些事件的事件线是这样的：

```js
// onscroll，请求1
// onscroll，请求2 响应1
// onscroll，请求3 响应2
// 响应3
// onscroll，请求4
// onscroll，请求5
// onscroll，请求6 响应4
// onscroll，请求7
// 响应5
// 响应6
// 响应7
```
但是前面介绍过事件循环的概念，js一次只能处理一个事件，所以要么是onscroll,请求2先发生，要么是响应1先发生，但不会严格的地同时发生。
这就像学校食堂的孩子们，不管在门外多么的拥挤，最终他们都得站成一队才能拿到自己得午饭。

下面列出事件循环队列中所有这些交替的事件：

```js
// onscroll，       请求1 启动    
// onscroll，请求2 
// 响应1            进程2 启动
// onscroll，请求3 
// 响应2
// 响应3
// onscroll，请求4
// onscroll，请求5
// onscroll，请求6 
// 响应4
// onscroll，请求7  进程1 结束
// 响应6
// 响应5
// 响应7            进程2 结束
```

"进程"1和"进程"2并发运行（任务级并行），但是它们的各个事件是在事件循环队列中依次运行的。

另外，注意到响应6和响应5的返回是乱序的了吗？

单线程事件循环是并发的一种形式（当然还有其他形式，后面会介绍）。

### 4.1 非交互

两个或多个“进程”在同一个程序内并发地交替运行它们的步骤/事件时，如果这些任务彼此不相关，就不一定需要交互。如果进程间没有相互影响的话，不确定性是完全可以接受的。

举例来说：
```js
var res = {};
function foo(results) {
    res.foo = results;
}
function bar(results) {
    res.bar = results;
}
ajax("http1", foo);
ajax("http2", bar);
```
foo()和bar()是两个并发执行的进程，按照什么顺序执行是不确定的。但是，我们构建程序的方式使得无论按哪种顺序执行都无所谓，因为它们独立运行，
不会相互影响。

这并不是竞态条件bug，因为不管顺序如何，代码总会正常工作。

## 4.2 交互

更常见的情况是，并发的“进程”需要相互交流，通过作用域或DOM间接交互。正如前面介绍的，如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。

下面是一个简单的例子，两个并发的“进程”通过隐含的顺序相互影响，这个顺序有时会被破坏：

```js
var res = [];
function res (data) {
    res.push(data);
}
ajax("http1", res);
ajax("http2", res);
```

这里的并发“进程”是这两个用来处理Ajax响应的res()调用。它们可能以任意顺序运行。

我们假定期望的行为是res[0]中放调用"http://some.url.1"的结果，res[1]中放调用"http://some.url.2"的结果。

有时候可能是这样，但有时候却恰好相反，这要视哪个调用先完成而定。

这种不确定性很有可能就是一个竞态条件bug。

所以，可以协调交互顺序来处理这样的竞态条件：

```js
var res = [];
function res (data) {
    if (data.url === "http1") {
        res[0] = data;
    } else {
        res[1]= data;
    }
}
ajax("http1", res);
ajax("http2", res);
```

## 4.3 协作

还有一种并发合作方式，称为并发协作（cooperative concurrency），这里的重点不再是通过共享作用域中的值进行交互（尽管显然这也是允许的！）。

这里的目标是取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行。

举例来说，考虑一个需要遍历很长的结果列表进行值转换的Ajax响应处理函数。我们会使用Array#map让代码更简洁。

```js
var res = [];
function responese(data) {
    res = res.concat(data.map(function(val) {
        return val * 2
    }))
}
ajax("http1", responese);
ajax("http2", responese);
```
如果"http1"首先取得结果，那么整个列表会立刻映射到res中。如果记录有几千条或更少，这不算什么。

但是如果有像1000万条记录的话，就可能需要运行相当一段时间了（在高性能笔记本上需要几秒钟，在移动设备上需要更长时间，等等）。

这样的“进程”运行时，页面上的其他代码都不能运行，包括不能有其他的responese(..)调用或UI刷新，甚至像滚动、输入、按钮这样的用户事件。
这是相当痛苦的。

所以要创建一个协作性更强更友好且不会霸占事件的事件循环队列的并发系统，你可以异步地批处理这些结果。每次处理之后返回事件循环，让其他
等待事件有机会运行。

这里给出一种非常简单的方法：

```js
var res = [];
function responese(data) {
    var chunk = data.splice(0, 1000)
    res = res.concat(chunk.map(function(val) {
        return val * 2
    }))
    if (data.length > 0) {
        setTimeout(function() {
            responese(data);
        }, 0)
    }
}
ajax("http1", responese);
ajax("http2", responese);
```
我们把数据集合放在最多包含1000条项目的块中。这样，我们就确保了“进程”运行时间会很短，即使这意味着需要更多的后续“进程”，因为事件循环队列的交替运行会提高站点/App的响应（性能）。

当然，我们并没有协调这些进程的顺序，所以结果的顺序是不可预测的。

这里使用setTimeout(..0)（hack）进行异步调度，基本上它的意思就是“把这个函数插入到当前事件循环队列的结尾处”

## 5 任务

在ES6中，有一个新的概念建立在事件循环队列之上，叫作任务队列（jobqueue）。这个概念给大家带来最大的影响可能是Promise的异步特性。

我认为对于任务队列最好的理解方式就是，它是挂在事件循环队列的每一个tick之后的一个队列。在事件循环的每个tick中，可能出现的异步动作不会
导致一个完整的新事件添加到事件循环，而会在当前tick的任务队列末尾添加一个项目（任务）。

这就好像：“哦，这里还有一件事情将来要做，但要确保在其他任何事情发生之前就完成它。”

事件循环队列类似于一个游乐园游戏：玩过一个游戏之后，你需要重新到队尾排队才能再玩一次。而任务队列类似于玩过游戏之后，插队接着继续玩。

一个任务可能引起更多任务被添加到同一个队列末尾。所以，理论上说，任务循环（job loop）可能无线循环（一个任务总是添加另一个任务，一次类推），
进而导致程序的饿死，无法转移到下一个事件循环的tick。从概念上看，这和代码中的无限循环（while(true)）的体验几乎一样。

任务和setTimeout(..0)hack的思路类似，但是其实现方式的定义更加良好，对顺序的保证性；更强：尽可能早的将来。

设想一个调度任务（直接地，不要hack）的API，称其为schedule(..)。考虑：

```js
console.log("A");

setTimeout(function(){
    console.log("B")
}, 0)
// 理论上的“任务API”
schedule(function() {
    console.log("C")
    schedule(function() {
        console.log("D")
    })
})
```

可能你认为这里会打印出A B C D，但实际打印的结果是A C D B。

因为任务处理是在当前事件循环tick结尾处，且定时器触发是为了调度下一个事件循环tick（如果可用的话！）。

在第3章中，我们将会看到，Promise的异步特性是基于任务的，所以一定要清楚它和事件循环特性的关系。